# 보이저엑스

- [채용 공고](https://v6xcareer.notion.site/2f61a1b40c81495eaf564cde9efc6089)


### 백엔드 개발자 기술 질문: 15개 중 8개 이상 잘 대답할 수 있어야 함

Q1. Base64 인코딩이란?
바이너리 데이터를 문자열로 인코딩 하기 위한 방법 중 하나입니다. Base64는 64개의 문자로 바이너리 데이터를 표현
합니다. 바이너리 데이터를 64비트 단위로 나누어 해당 비트열에 대응 되는 문자로 치환합니다. 나눠 떨어지지 않는 부
분은 패딩을 넣어 채워 넣습니다. 과거 TOTP 인증 앱 프로젝트에서 RFC 문서를 보고 직접 알고리즘을 구현해 본 경험을
가지고 있습니다.

+ (추가) 인코딩 후 메모리 변화
-> Base64는 6bit 마다 아스키데이터로 변환. 즉 6bit가 8bit가 됨. 약 1.333배 커짐. 

Q2. 사용자 패스워드를 전송/보관하는 방법은?
그대로 전송하거나 보관하면 보안상 문제가 발생할 수 있기 때문에 해시화를 통해 원본을 알 수 없게 만들어야 합니다.
이 과정에서 암호화 알고리즘을 적용할 수 있고, 매번 해시값이 달라지는 암호화 알고리즘으로 보안을 강화할 수 있습니
다.

Q3. system call이란?
OS가 컴퓨터의 기능을 추상화하여 제공하는 API입니다. OS에서 실행되는 프로그램들은 OS가 제공해주는 system
call을 사용하여 컴퓨터의 기능들을 사용할 수 있습니다. 프로그램들이 바로 컴퓨터 자원을 사용하지 못하게 하여 중간
에서 OS가 system call을 실행하는 과정에서 리소스 분배 또는 보안 이슈를 해결할 수 있게 됩니다.

Q4. .so와 .a 파일의 차이는?
.so는 공유 라이브러리이고 프로그램 파일에 포함되지 않아 해당 코드를 실행할 때 라이브러리 코드를 로드하여 실행 속
도가 느릴 수 있습니다. 반면, .a 파일은 정적 라이브러리로 컴파일 타임에 프로그램에 포함되어 처음 프로그램 로딩 시
간은 느리지만, 해당 코드 실행 속도가 빠릅니다.

Q5. MySQL과 MongoDB의 차이점은?
MySQL은 관계형 데이터베이스로 정형화된 데이터들을 관리하기 위해 사용되고 MongoDB는 정형화되지 않은 데이터
를 유연하게 저장하는 방식으로 사용됩니다.

+ (추가)
- 몽고디비는 샤딩(sharding)을 통해 데이터를 여러 개의 서버(Shard)로 자동 분산.
    - 읽기/쓰기 부하를 여러 서버에 나눠 처리하여 성능 향상
    - 애초에 분산되는 구조라 확장시(scale-out) 유리
- 문서 단위로 저장하는 몽고 디비는 JOIN이 거의 없어 확장성이 뛰어남
- mysql은 단일 마스터-슬레이브 구조라 성능 향상 한정적, 몽고디비는 여러 primary 노드를 구성하여 병렬 처리 가능

Q6. HTTP/2의 특징은? (몰랐음)
- HTTP/1은 한 번의 요청에서 필요한 리소스들을 각각 TCP 연결을 맺어서 순서대로 가져옴 - 느림
- HTTP/1.1은 각각 연결을 맺지는 않지만, 순서대로 하나씩 가져옴
- HTTP/2 부터는 모든 리소스를 병렬적으로 가져옴 - 빠름
- HTTP/3 부터는 심지어 UDP라서 엄청 빠름

Q7. Firewall의 동작 원리는? (몰랐음)
- 네트워크 계층마다 다름
- 커널 계층(네트워크 3,4)
    - 패킷의 헤더 정보 분석하여 허용 차단 결정
    - TCP 연결 상태를 추적하여 신뢰가능한 패킷만 허용
- 애플리케이션 계층(네트워크 5,6,7)
    - 패킷 데이터를 검사하여 보안 강화
        - SQL Injection, XSS 같은 공격 탐지 가능 - 느릴 수 있음
- 방화벽 왜?
    - 일종의 역할 분담이라고 봄
    - 애플리케이션은 자기의 비즈니스 로직에 집중
    - 자주 발생하는 보안 문제는 방화벽에서 미리 처리

Q8. Docker와 Virtual Machine의 차이점은?
도커는 호스팅 OS의 커널을 공유하며, cgroups와 같은 리눅스의 격리 기술을 사용하여 호스팅 OS의 자원을 격리하여
사용합니다. 가상 머신은 호스팅 OS 위에 게스트 OS를 실행합니다. 그래서 도커가 더 가볍고 빠릅니다.

Q9. AMD와 Intel CPU의 차이점은?
AMD는 단순한 구조로 빠르게 실행하는 RISC 구조를 따르며 Intel은 복잡한 구조로 다양한 기능을 제공하지만 느린
CISC 구조를 따릅니다. 시스템 프로그래밍 수업을 들을 때 교수님께서 Intel은 과거 레거시 구조까지 안고 가야하기 때
문에 CISC 같이 느린 구조도 어쩔 수 없이 사용한다고 했던 이야기가 생각이 납니다.

Q10. CRDT란? (몰랐음)
- 분산환경에서 동시에 데이터를 수정하다가 충돌이 발생해도 자동으로 해결되도록 설계된 데이터 구조
- 복잡한 방법이 있는데 이건 나중에 필요할 때 찾아보자!

Q11. CORS란?
리소스의 교차 출처를 허용하는 정책입니다. 과거 리액트가 유행하기 전에, 프론트와 백엔드가 한 번에 처리 되던 시절에
는 다른 출처에서 서버에 요청하는 것은 보안상 위험한 행위였습니다. 출처가 다른 리소스 요청에 대해 막는게 당연했지
만, 웹 서버의 기능과 목적이 다양해지면서 다른 출처에서 요청하는 경우가 많아졌고 CORS 정책이 추가되었습니다. 서
버에서는 헤더 설정을 통해 다른 출처에 대한 요청을 허락하도록 할 수 있습니다.

Q12. CI/CD란?
CI는 지속적 통합으로, 코드를 병합하고 자동 테스트를 통해 코드 품질을 빠르게 확인하는 과정입니다. CD는 지속적 배
포와 전달을 의미하고 통합된 코드를 자동으로 배포하는 과정입니다. 젠킨스를 통해 CI/CD 환경을 구축해보았고, 최근
에 프로젝트에서는 Git Actions를 통해 손쉽게 자동화를 할 수 있었습니다.

Q13. 동시 사용자 1만명을 지원하는 채팅 서버를 어떻게 만들겠는가?
직전 회사에서 1만명이 동시에 참여하는 채팅 서버를 유지 보수 한 경험이 있습니다.
먼저 채팅 서버에서는 웹소켓을 사용하여 세션을 맺어 클라이언트와 통신합니다. 이 때 메시지를 처리하는 로직이 블로
킹되지 않도록 비동기 처리에 유의해야 합니다. WebFlux나 RxJava와 같은 비동기 처리 기술을 통해 비동기 플로우를
직관적으로 처리할 수 있습니다.
메시지가 들어오면 채팅서버에서 직접 브로드캐스트하지 않고 메시지 큐에 해당 메시지를 전달하여 비동기적으로 처리
합니다. 이렇게 하면 소켓 서버에서 브로드캐스트 하는 부담을 줄이고 메시지의 순서를 보장할 수 있습니다. 메시지 큐를
구독하고 있는 메시지 처리 서버는 해당 메시지의 채팅 방에 속해 있는 유저들에게 해당 메시지를 전달합니다.

Q15. 대용량 로그 시스템을 구축한다면 어떻게 하겠는가?
먼저 로그 처리를 비즈니스 로직을 처리하는 응용 프로그램에서 처리하지 않도록 분리해야 합니다. 응용 프로그램에서
로그를 디스크 어딘가에 보관하면, 로그 수집기 프로그램을 따로 추가하여 일정 주기마다 로그를 수집하도록 합니다. 그
리고 중앙 메시지 처리 큐를 통해 해당 로그들을 모아 중앙 로그 저장소에 저장하도록 합니다.
이전 회사에서는 Beats를 통해 로그를 수집하고 Logstash로 카프카에 로그를 전송하였습니다. 그리고 Opensearch
를 사용하여 해당 로그들을 저장하였습니다.

