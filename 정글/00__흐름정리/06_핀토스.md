# 핀토스 프로젝트 흐름
- OS가 결국 해야 하는 것들이 뭔지 생각해보자
- OS는 하나의 컴퓨터 시스템 자원을 여러 개의 프로그램이 공유할 수 있게 도와주는 프로그램이다.
- 프로세스, 스레드, 스케줄링, 동시성, 우선순위, 유저 프로그램, 시스템콜, 사용자/커널 모드, 페이지 테이블, 스왑 
    - 이 모든 개념들이 결국에는 여러 개의 프로그램이 OS에 컴퓨터 자원을 요청했을 때, 
    - OS가 이 요청을 수행하는 과정에서 반드시 필요한 작업을 수행해주는 기술들이다.
- 핀토스는 이 기술들을 직접 로우 레벨에서 구현하며 OS가 여러 개의 프로그램을 관리, 실행 시켜주는 과정을 경험할 수 있도록 구성되어 있다.

## 프로젝트 1 스레드 (Threads)

#### 목표
- 커널 스레드 관리
- 스케줄링 개선

#### 주요 개념
- 스레드 구조 
- 컨텍스트 스위칭
- 동기화
- 세마포어

#### 왜 첫 번째 프로젝트가 스레드인가
- 운영체제에서 가장 기본적인 개념이 __CPU 스케줄링__
- CPU가 여러 개의 작업을 수행해야 하므로, 여러 개의 스레드를 어떻게 관리하는지가 중요
- 스레드 생성 및 스케줄링을 직접 구현하여 스레드 관리 방법 습득

#### 구현 내용
- sleep
    - cpu를 사용하면서 기다리냐, cpu를 사용하지 않고 기다리냐의 차이를 이해 -> 중요!!!
    - 나중에 락처리할 때도, 락으로 기다릴 때 block이 되는데, 이 때 cpu를 사용하지 않고 기다림!
    - 현재 실행 중인 thread list에서 lock list로 옮김!!!
- 스레드 스케줄러 개선
    - 스레드를 생성하고 실행하는 코드(__thread_create__, __schedule__) 분석
    - 기본 라운드 로빈 스케줄러 개선 (우선순위 기반 스케줄링 추가)
- 우선순위 기아 현상 해결
    - 우선순위가 높은 스레드가 계속 실행되는 문제 해결
    - __Priority Donation__ 기법 구현
- 동기화 문제 해결 (세마포어, 락, 조건변수)
    - 여러 스레드가 공유 데이터를 안전하게 다룰 수 있도록 __세마포어(sema_up, sema_down)__ 활용

#### 배우는 내용
- 스레드와 컨텍스트 스위칭
- CPU 스케줄링 (라운드 로빈, 우선순위 스케줄링)
- 동기화 (세마포어, 락, 조건변수)

---

## 프로젝트 2 유저 프로그램 실행 (User Programs)

#### 목표
- 사용자 프로세스 실행 및 시스템 콜 구현

#### 주요 개념
- 프로세스
- 시스템콜
- __ELF 실행 파일 로딩__
- __사용자/커널 모드 전환__

#### 왜 두 번째 프로젝트는 유저 프로그램인가?
- 운영체제는 결국 사용자 프로그램을 실행하는 역할을 담당
- 첫 번째 프로젝트에서 만든 __'스레드 관리'__ 기능을 확장
- **_사용자 프로세스를 실행_**하고, **_커널과 유저 프로그램 간 인터페이스_**를 다뤄 봄

#### 구현 내용
- 유저 프로세스 로드 및 실행
    - ELF 실행 파일을 커널에서 로드 (__load()__)
    - 페이지 테이블을 설정하여 가상 주소 공간 할당
- 시스템 콜 인터페이스 구현
    - __syscall_handler()__에서 시스템 콜 처리
    - exec, exit, wait, write, read 등의 시스템 콜 구현
- 프로세스 간 관계 관리 (부모-자식 관계)
    - process_wait()를 구현하여 부모가 자식 프로세스의 종료를 __기다리도록__ 구현
- 유저 프로그램의 메모리 접근 보안 처리
    - 커널이 유저 프로그램의 잘못된 메모리 접근을 방지하도록 예외 처리 (__page fault__ 대응)

#### 배우는 내용
- 프로세스 관리 (생성, 종료, 부모-자식 관계)
- 시스템 콜과 커널-유저 모드 전환
- 유저 프로그램 로딩 및 실행

---

## 프로젝트 3 가상 메모리 (Virtual Memory)

#### 목표
- 가상 메모리 시스템 구현

#### 주요 개념
- 페이지 테이블
- 스택 증가
- 스왑 (Lazy Loading, Demand Paging)

#### 왜 세 번째 프로젝트는 가상 메모리인가?
- 유저 프로그램을 실행하려면 메모리 관리가 필수
- OS에서는 프로세스마다 고유한 가상 주소 공간을 가지고, 이를 효율적으로 관리
- 이전 프로젝트에서 만든 유저 프로그램 실행 기능을 확장하여 메모리를 동적으로 관리할 수 있도록 함

#### 구현 내용
- Lazy Loading (지연 페이지 로딩) 구현
    - 프로그래밍 실행될 때 필요한 페이지만 메모리에 로드
- 스택 크기 증가 구현
    - 유저 스택이 초기에 할당된 공간을 초과하면, 새로운 페이지를 할당하도록 구현
- 스왑 구현
    - 메모리가 부족할 경우, 사용하지 않는 페이지를 디스크로 스왑
    - __swap in__, __swap out__ 기능 추가

#### 배우는 내용
- 가상 메모리와 물리 메모리 관리
- 지연 페이지 로딩 (Lazy Loading)
- 스왑 (Swap)
- 페이지 폴트 처리

---

## 프로젝트 4 파일 시스템 (File System)

#### 목표
- 파일 시스템 구현 및 개선

#### 주요 개념
- 파일 시스템 구조, 디렉토리, 캐시, 파일 동기화

#### 왜 네 번째 프로젝트는 파일 시스템인가?
- 파일 시스템은 운영체제의 핵심 기능
- 사용자는 파일을 저장하고 읽는 기능이 필요
- 이를 효율적으로 관리하기 위해 캐싱, 동기화, 디렉토리 구조를 설계해야 함

#### 구현 내용
- 파일 시스템 확장
    - 기존 파일 시스템을 개선
    - 더 큰 파일을 처리할 수 있도록 수정
- 디렉토리 구조 추가
    - 계층적 파일 시스템을 구현, 디렉토리 지원
- 파일 캐싱(Buffer Cache) 구현
    - 디스크에서 파일을 읽을 때 성능을 향상시키기 위한 캐시 메커니즘 추가
- 파일 시스템 동기화
    - 시스템 종료 시 변경된 파일 데이터를 디스크에 동기화 하는 기능 추가

#### 배우는 것
- 파일 시스템의 내부 구조
- 디렉토리 및 파일 관리
- 버퍼 캐시와 성능 최적화
- 데이터 동기화 및 무결성 유지

---

## 프로젝트 모두 완료시
#### 배우는 것
- CPU 스케줄링과 멀티스레드 관리
- 프로세스 생성 및 시스템 콜 인터페이스
- 가상 메모리 및 페이지 테이블
- 파일 시스템 구조 및 동기화 기법

#### 흐름
- 스레드 -> 프로세스 -> 메모리 -> 파일 시스템
- 운영체제의 핵심 개념을 확장
- 운영체제가 어떻게 동작하는지 직접 구현하면서 이해할 수 있게 됨

---

## 트러블 슈팅

#### 프로젝트 1
- 멀티레벨 큐 스케줄링 구현
    - 스레드 destroy 시 전체 스레드를 담아 둔 리스트를 정리하지 않아 런타임 에러
- 연결 리스트에 들어가는 변수를 연결 리스트 마다 만들어 주지 않아 문제 발생

#### 프로젝트 2
- 인터럽트 컨텍스트에서 스케줄링 시도하여 문제 발생
    - 인터럽트 컨텍스트에서 실행되는 작업은 thread_yield를 하면 안되는데, 이를 구분하지 않고 무조건 thread_yield를 해서 문제 발생
    - intr_context()가 아닐 때만 실행하도록 수정하여 해결
    - 중요!: 인터럽트 컨텍스트의 작업들은 스케줄링을 하면 안된다!
        - blocking을 하면 안됨!
        - 왜? 인터럽트 컨텍스트는 빠르게 실행되고 끝내야 하기 때문!! - 넘어가면 안됨!

#### 프로젝트 3
- static을 잘못 선언해서 문제 발생
    - 다른 파일에서 접근 못하게 됨
    - 컴파일 에러가 발생하지 않고, 해당 변수에 다른 파일에서 접근시 스레기 값이 반환되어 락이 제대로 처리 되지 않는 문제 발생