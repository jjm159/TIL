# Introduction

## project 3 Virtual Memory
- 가상 메모리 구현
- 현재까지는, 메인 메모리의 크기에 제한됨
- 메인 메모리 크기에 제약되지 않고, 무한한 메모리 환상(illusion)을 만들 것

## Background
- 반드시 템플릿 코드 안에서 작업
- Do not change 변경 X

### source files

#### include/vm/vm.h, vm/vm.c
- 가상 메모리의 일반적인 인터페이스 제공
- 가상 메모리 시스템이 지원해야 하는 다양한 vm_type
    - VM_UNINIT
    - VM_ANON
    - VM_FILE
    - VM_PAGE_CACHE
        - 지금은 무시(프로젝트 4)
- 보조 페이지 테이블을 구현할 것

#### include/vm/uninit.h, vm/uninit.c
- 페이지들이 초기화 되어 있지 않음
- 이후에 익명 페이지나 파일 기반 페이지로 변환될 것

#### include/vm/anon.h, vm/anon.c
- anonymous 페이지들에 대한 작업을 제공 (vm_type = VM_ANON)

#### include/vm/file.h, vm/file.c
- 파일 기반 페이지들에 대한 작업을 제공 (vm_type = VM_FILE).

#### include/vm/inspect.h, vm/inspect.c
- 평가를 위한 메모리 검사 작업을 포함
- 변경하면 안됨

#### include/devices/block.h, devices/block.c
- 블록 장치에 대한 섹터 기반의 읽기 및 쓰기 접근을 제공

---

### Memory Terminology

#### 페이지
- 가상 페이지라고도 함
- 4096 바이트 길이 가짐 - 연속적
- 페이지 정렬 되어야 함
    - 페이지 크기로 균등하게 나누어지는 가상 주소에서 시작해야 함
    - 64비트 가상 주소의 마지막 12비트는 페이지 오프셋임
    - 상위 비트는 페이지 테이블의 인덱스를 나타내는 데 사용

#### 가상 주소
- 각 프로세스는 `독립적인 가상 페이지 집합` 을 가짐
- 이 주소들은 KERN_BASE 아래의 페이지들임
- 커널은 사용자와 커널 페이지 모두에 접근 가능
- 사용자는 자신의 사용자 페이지에만 접근 가능
- 가상 주소를 작업하기 위한 여러 유용한 함수
    - Section Virtual Address 참고

#### 프레임
- 연속적인 물리적 메모리 영역
- 페이지 크기이고 페이지 정렬 되어야 함
- 64비트 물리 주소는 프레임 번호와 프레임 오프셋으로 나눠짐

#### 물리 주소
- x86-64 물리 주소에서 메모리에 직접 접근하는 방법 X
- 커널 가상 메모리를 물리 메모리에 직접 매핑하여 해결
    - 커널 가상 메모리의 첫 `페이지`는 물리 메모리의 첫 `프레임`에 매핑

#### 페이지 테이블
- CPU가 가상 주소를 물리 주소로 변환하는 데 사용하는 데이터 구조
- 페이지 테이블 형식은 x86-64 아키텍처에 의해 결정
- Pintos에서는 `threads/mmu.c`에서 페이지 테이블 관리 코드 제공
- 가상 주소는 페이지 번호와 오프셋으로 구성. 페이지 테이블은 페이지 번호를 프레임 번호로 변환, 수정되지 않은 오프셋과 결합하여 물리 주소를 얻음

#### 스왑 슬롯
- 스왑 파티션의 디스크 공간에서, 페이지 크기의 영역

---

## 리소스 관리 개요
- 다음 자료 구조들을 설계하고 구현해야 함
    - supplemental page table
        - 페이지 폴트 처리를 가능하게 만듬
    - Frame table
        - 물리 프레임의 제거 정책을 효율적으로 구현하도록 함
    - Swap table
        - 스왑 슬롯의 사용을 추적

#### Choices of implementation (Performance perspective)
- 자료구조가 이미 있으니, 활용해서 구현하면 됨
    - bitmap.c
    - hash.c

---

## 1. Managing the Supplemental Page Table (보조 페이지 테이블 관리)
- 페이지에 대한 추가 데이터 - 페이지 테이블 보완
- 두 가지 목적
    - `페이지 폴트 발생` 시 보조 페이지 테이블에서 오류가 난 가상 페이지를 찾아서, 그 페이지가 어떤 데이터가 있어야 하는지를 알아냄
    - `프로세스가 종료`될 때, 보조 페이지 테이블을 참조해서 `어떤 리소스를 해제`할 지 결정
    
#### Organization of Supplemental Page Table (보조 테이블 조직)
- 두 가지 접근 방식
    - 페이지 관점
    - 세그먼트 관점
        - 연속적인 페이지 그룹
- 페이지 테이블 자체를 사용해서 보조 페이지 테이블을 추적 할 수 있음 (option)
    - mmu.c의 페이지 테이블 구현을 수정해야 함
    - advanced만!

#### Handling page fault
- 프로젝트 2 까지는 버그만을 의미
- 프로젝트 3 부터는 버그 뿐만이 아니라, 파일이나 스왑 슬롯에서 페이지를 가져와야 함을 의미할 수 있음 
- userprog/exception.c의 page_fault()에서 호출하는 vm/vm.c의 vm_try_handle_fault()를 구현해야 함
- 첫 번째
    - 오류가 발생한 페이지를 보조 페이지 테이블에서 찾음
    - 유효한 경우, 페이지에 들어갈 데이터를 보조 페이지 테이블에서 찾음
    - 이는 파일 시스템에 있거나, 스왑 슬롯에 있거나, 단순히 0으로 초기화된 페이지일 수 있음
    - sharing(copy on write)을 구현한 경우, 
        - 페이지의 데이터가 이미 페이지 프레임(물리)에 있을 수 있지만, 페이지 테이블에는 없을 수 있음
    - 유효하지 않은 경우
        - 보조 페이지 테이블이 사용자 프로세스가 접근하려는 주소에 어떤 데이터도 예상하지 않아야 함을 나타내거나
        - 페이지가 커널 가상 메모리 내에 있거나
        - 접근이 읽기 전용 페이지에 쓰기를 시도하는 경우
    - 유효하지 않은 모든 접근은 프로세스를 종료시키고, 모든 리소스를 해제해야 함
- 두 번째
    - 페이지를 저장할 프레임을 get
    - sharing 구현 시
        - 필요 데이터가 이미 프레임에 있을 수 있음
        - 해당 프레임을 찾을 수 있어야 함
- 세 번째
    - 프레임에 데이터 fetch
        - 파일 시스템이나 스왑에서 get
        - 0으로 초기화
    - sharing 구현 시
        - 필요 페이지가 이미 프레임에 있을 수 있음
        - 이런 경우 아무 작업도 필요하지 않음
- 네 번째
    - 가상 주소의 페이지 테이블 엔트리를 물리 페이지에 지정
    - threads/mmu.c의 함수를 사용

---

## 2. Managing the Frame Table
- frame table은 프레임 하나에 하나의 엔트리 가짐
    - 해당 frame을 점유하는 페이지에 대한 포인터와 기타 데이터 있음
    - 프레임이 없으면(물리 메모리에서 사용 가능한) 페이지를 교체해서 an eviction policy을 효율적으로 구현
- user 페이지에 사용되는 frame은 `palloc_get_page(PAL_USER)`를 호출하여 "user pool"에서 얻어야 함
- frame table에서 가장 중요한 작업은 사용되지 않는 frame을 얻는 것
    - 비어 있는 프레임이 없으면 프레임에서 일부 페이지를 교체(evict)해야 함
- swap sloy을 할당하지 않고 교체할 수 있는 프레임이 없지만, swap이 꽉 차면, 커널을 panic 시켜라
    - 실제로는 더 복잡한 정책이 있지만, 핀토스에서는 X
- eviction process
    - 페이지 교체 알고리즘 적용. 교체할 프레임 선택
        - accessed, dirty 필드 
    - 해당 프레임을 참조하는 모든 페이지 테이블에서 프레임에 대한 참조를 제거
        - 공유 구현 X시, 한 번에 단일 페이지만 프레임을 참조해야 함
    - 필요한 경우, 페이지를 파일 시스템이나 스왑에 사용
        - 교체된 프레임은 다른 페이지를 저장하는 데 사용

#### Accessed and Dirty Bits
- x86-64 하드웨어는 1bit를 사용해서 페이지 교체 알고리즘에 사용
- 페이지에 대한 read, write 발생 시, 
    - CPU는 페이지의 PTE에서 accessed 비트를 1로 설정
- 쓰기가 있을 때에는 
    - dirty bit를 1로 체크
- OS만 체크 가능
- aliases
    - 프레임을 참조하는 두 개 이상의 페이지
    - alias 페이지에 접근 시, 
        - accessed, dirty bit는 접근된 페이지 테이블에서만 업데이트 됨
    - alias 된 다른 페이지는 업데이트 안됨
- 모든 가상 페이지는 해당 커널 가상 페이지에 alias됨
    - (핀토스는 유저 데이터에 접근할 때 커널 페이지가 유저 페이지의 프레임을 참조하는 alias 방식으로 하게 됨)
    - 위에 설명했듯, 하나의 페이지 테이블만 업데이트 되기 때문에 주의해야 함

---

## 3. Managing the Swap Table
- 스왑 테이블은 in-use and free swap slots을 tracking
- 페이지 교체 시, 사용되지 않은 swap slot을 선택할 수 있어야 함
- 페이지가 다시 읽혀지거나, 프로세스 종료시 스왑 슬롯 해제도 가능해야 함
- 실제로 페이지 교체가 필요할 때만 할당되어야 함 (lazy 해야 함)
    - 페이지를 읽을 때 바로 swap slot에 할당하는 건, lazy 하지 않음
- 특정 페이지를 저장하기 위해 예약 되면 안됨
- 프레임으로 다시 할당되면, 스왑 슬롯 해제 되어야 함

---

## Managing Memory Mapped Files
- mmap 시스템 콜로 파일을 가상 페이지에 매핑할 수 있음
- 파일을 직접 메모리에 매핑함으로써, 메모리 접근 명령어로 파일에 접근 가능해짐
- 어떤 메모리가 파일 메모리 매핑에 사용되었는지 track할 수 있어야 함