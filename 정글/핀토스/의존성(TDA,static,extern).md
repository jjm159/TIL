# static과 extern 그리고 의존성

## 개요
- 핀토스는 역사가 있는, 수 많은 사람들이 os학습을 위해 거쳐간 검증된 프로그램이다.
- C언어를 사용해서 어느 정도 규모가 있는 프로젝트로서, 여러 C 파일들이 합쳐져 거대한 프로그램을 완성한다.
- 당연하게도, 의존성 문제에 직면했을 것이고, 나름대로 이 문제를 해결하는 C언어 프로젝트의 여러 방법들이 있을 것이다.
- 그 중에서 static과 extern에 대해 알아보면 좋을 것 같다. 
- C언어는 객체지향 언어는 아니기 때문에 Class 문법이 제공해주는 다양한 캡슐화 기능들을 사용할 수는 없지만,
- 파일 단위로 접근을 제한해서 캡슐화를 지원해주는, 그래서 의존성이 복잡하게 얽히는 문제를 해결할 수 있는 키워드가 있다.
- 그게 static과 extern이다.
- 이 두 키워드에 대해 알아보고, 의존성은 무엇인지, 그리고 이 키워드를 통해 의존성이 높아지는 실수를 방지하는 방법에 대해 알아 보았다.

## 의존성

### 의존성이 뭔데?

- 쉽게 말하면, A라는 파일(c언어니까 class가 아님)에서 B라는 파일의 함수나 변수를 사용하면 의존관계가 형성 된다.
- 의존성은 이러한 의존 관계가 얼마나 많이 존재하는지에 대한 척도다.

### 의존성이 높으면?

- 안좋다.
- 그래서 줄일 수 있는 만큼 최대한 줄이는 것 좋다.
- A 파일이 B 파일의 어떤 변수를 가져와서 연산을 수행하는 상황에서, B가 해당 변수를 수정하게 된다면, A의 파일도 가서 사이드 이펙트가 없을지 확인하고 수정해야 한다.
- 이런 의존 관계가 많아질 수록, 수정시 개발자가 확인해야 하는 파일의 개수와 코드의 개수가 늘어난다.
- 이런 상황을 유지 보수 비용이 높아진다고 하는 것이다.
- 그래서 될 수 있다면, 최대한 파일 안에 있는 데이터들을 감춰야 한다. 외부에서 직접 접근하고 가져와서 연산을 수행하는 것을 막아야 한다.

### 감추는 방법
- TDA - Tell, Don't Ask
- 객체지향 프로그래밍에서 중요한 키워드이다.
- 객체에게 어떤 데이터를 달라고 `요청`하지 말고,
- 해당 데이터를 어떻게 조작해 달라고 `시키`라는 것이다.
- 해당 멤버 변수를 가져와서 직접 조작하는 순간, 의존성이 생겨 버리기 때문에,
- 해당 멤버 변수에 대한 조작을 해당 클래스가 하도록 만들라는 것이다.
- 해당 멤버 변수를 가진 파일에서 해당 변수를 사용해서 로직을 수행하는 메서드를 추가하고, 이 메서드로 `시키`라는게 TDA다.

### C언어에서 TDA
- C 언어에서는 class가 아닌 파일 단위로, 
- 해당 파일에서 관리하는 데이터를 외부에서 직접 참조해서 사용하는 게 아니라 
- 해당 파일에 함수를 추가해서 해당 데이터를 가진 파일이 해당 데이터를 수정하는 방식으로 TDA를 적용해 볼 수 있을 것이다.

## static과 extern
- 객체지향 언어에서 class의 내부에 접근을 제한하는 접근 제한자 키워드가 있듯, C언어에서는 파일 내 변수나 함수에 대한 접근을 외부에서 얼마나 허용할지를 결정하는 키워드가 있다.
- 그게 static과 extern이다.

### static이랑 extern은 뭔데?
- static으로 선언한 변수나 함수는, 해당 파일 외부에서 접근할 수 없다.
- 반대로 extern으로 선언한 변수나 함수는, 해당 파일 외부에서 접근할 수 있다.

### static과 extern으로 의존성 줄이기
- 파일 내에 있는 글로벌 변수들은 static으로 최대한 캡슐화를 해주고
- 최대한 해당 변수를 파일 외부에서 직접 사용해서 연산하는 상황을 방지할 수 있다.


## 예시 - TDA가 깨진
- 팀원의 코드를 리뷰하는 과정에서 정확하게 TDA 원칙이 깨져서 의존성이 높아진 문제가 발견되었다.
- time.c 에 있는 timer_interrupt에서 thread.c에 있는 get_next_tick_to_awake와 awake_thread를 호출하고 있다.
```c
static void timer_interrupt () { // time.c의 함수
    if (get_next_tick_to_awake() <= ticks) { // thread.c의 함수
        awake_thread(ticks);
    }
}
```
- get_next_tick_to_awake 가 전형적으로 TDA를 무시한 함수다.
- thread.c에서 관리하고 있는 전역변수를 그대로 가져와서  time.c에서 비교 연산을 수행하고 있다.
- 만약 해당 변수가 변경된다면, thread.c까지 확인해서 사이드 이펙트가 없는지 확인하고, 올바르게 동작하기 위해 코드를 수정해야 하는 공수가 추가된다.
- TDA에서는 해당 변수에 대한 연산을 최대한 변수가 선언된 파일(클래스)에서 수행하도록 한다.
- 그래서 다음과 같이 개선해 볼 수 있을 것이다.
    - thread.c
    ```c
    bool is_over_next_tick(int ticks) {
        return next_tick_to_awake <= ticks;
    }
    ```
    - time.c
    ```c
    static void timer_interrupt () { // time.c의 함수
        if (is_over_next_tick(ticks)) { // thread.c의 함수
            awake_thread(ticks);
        }
    }    
    ```
- 또는 awake_thread 안에서 비교 연산을 수행할 수도 있을 것이다.
