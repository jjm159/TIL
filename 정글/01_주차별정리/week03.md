# 학습 내용
- 동적 프로그래밍, 그리디

# 퀴즈 

## 1. 스택과 레지스터가 무엇인지, 용도와 장점

### 스택
스택은 프로시저 호출 시 지역 변수와 매개변수를 저장하기 위한 메모리 공간이다. 선언되는 순서와 반대로 메모리가 해제되는 LIFO 구조를 가진다. 

#### 용도
- 함수의 로컬 변수 저장
    - 함수 호출 시 해당 함수의 로컬 변수들이 스택에 저장된다.

#### 장점
- 동적으로 메모리를 할당하고 해제할 수 있다.
- 구현이 간단하고, 메모리 관리 overhead가 낮다.

### 레지스터
레지스터는 프로세서 내부의 고속 작동 메모리다. 프로시저 실행 중 자주 접근하는 변수나 중간 계산값을 저장하기 위해 사용된다.

#### 용도
- 중간 연산 결과 저장
    - 연산 중 생성되는 중간 값을 빠르게 저장하고 접근하기 위해 사용
#### 장점
- 매우 높은 데이터 접근 속도 제공
- 데이터 메모리로부터 레지스터로 빠르게 이동시킬 수 있어 연산 효율이 증가한다.

## 2. 꼬리 재귀 최적화(Tail Recursion Optimization)을 호출 스택(Call Stack) 관점에서 설명

꼬리 재귀 최적화는 재귀 함수 호출 시 호출 스택의 사용을 최적화 하는 기법이다.
재귀함수가 호출될 때 마다 스택 프레임이 생성되며, 이는 메모리 사용량 증가와 스택 오버플로우의 원인이 된다. 
꼬리 재귀 최적화는 재귀 함수의 마지막 연산만 호출 스택에 남겨두고, 나머지를 제거한다. 이를 통해 함수가 반환될 때 호출 스택을 재사용할 수 있다.
(꼬리 재귀 형태는 컴파일러가 호출 스택을 재활용 하는 방식으로 최적화를 할 수 가 있음)
구체적으로, 꼬리 재귀 함수는 반환값을 바로 return 하기 보다는 파라미터로 전달한다.
이렇게 하면 호출 스택에 쌓이지 않고 후속 호출로 이동된다.
마지막 호출에서 스택 프레임을 재활용하므로, 메모리 사용량이 일정하게 유지된다.


### 예시
#### 일반 재귀 구현
```c
int factorial(int n) {
    if (n==1) {
        return 1;
    }
    return n * factorial(n-1);
}
```

```
factorial(3)  → 스택에 push
  factorial(2)  → 스택에 push
    factorial(1)  → 스택에 push
      factorial(0)  → 스택에 push
      factorial(0) 반환 (1)  → 스택에서 pop
    factorial(1) 반환 (1 × 1)  → 스택에서 pop
  factorial(2) 반환 (2 × 1)  → 스택에서 pop
factorial(3) 반환 (3 × 2)  → 스택에서 pop
```

#### 꼬리 재귀 최적화 구현
```c
int factorialTail(int n, int acc) {
 if (n==1) {
    return acc;
 }
 return factorialTail(n-1, n*acc);
}

int factorial(int n) {
    return factorialTail(n, 1);
}
```

```
factorialTail(3, 1)  → 기존 스택 프레임 재사용
factorialTail(2, 3)  → 기존 스택 프레임 재사용
factorialTail(1, 6)  → 기존 스택 프레임 재사용
factorialTail(0, 6)  → 반환
```



## 3. 그리디 알고리즘과 동적 프로그래밍의 정의를 각각 쓰고, 동적 프로그래밍에서 상향식, 하향식 차이에 대해 설명

### 그리디 알고리즘
- 정의
    - 매 순간마다 가장 좋아 보이는 선택을 하는 알고리즘. 지역 최적화를 통해 전역 최적화를 도달하길 기대한다.
- 특징
    - 각 단계에서 최적의 해답을 찾아 나가면서 문제의 최적 해답을 찾아나가는 방식. 각 단계에서의 결정은 지금까지의 상황만을 고려하며, 이후의 상황은 고려하지 않는다.

### 동적 프로그래밍
- 정의
    - 복잡한 문제를 여러 개의 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 나중에 같은 하위 문제가 다시 발생하면 저장된 결과를 사용하는 알고리즘
- 특징
    - 중복된 하위 문제들을 여러 번 해결하는 것을 방지하여 효율성을 높임
    - 메모이제이션 또는 타뷸레이션 기법 사용

### 상향식과 하향식 차이
- 상향식
    - 작은 문제부터 차례대로 해결해 나가면서 큰 문제의 해결책을 구한다.
- 하향식
    - 큰 문제를 작은 문제로 나누어 해결한다.
    - 필요할 때 하위 문제를 해결한다.

## 4. introduction to algorithms 책 p.715에 있는 floyd-warshall 알고리즘을 사용해 방향 그래프의 이행적 폐쇄를 구하는 과정 단계별 도시 
- 책 참고