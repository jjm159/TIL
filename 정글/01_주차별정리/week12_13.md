# 12-13 주차
- 가상 메모리

## 학습 키워드 

#### Virtual Memory
- 프로그램이 연속적이고 독립적인 메모리 공간을 사용하는 것 처럼 만드는 기술
- 프로그램은 혼자 메모리를 점유한다고 치고 메모리 주소를 사용
- 실제 물리 메모리에는 중간에서 OS가 매핑 테이블로 매핑해서 관리
- 왜 이렇게?
    - 일관된 메모리 관리 기법 제공
    - 실제 메모리 크기에 상관없이 프로그램은 무한하게 메모리 관리 가능
    - 프로그램이 신경쓰지 않아도 알아서 물리 메모리를 여러 프로그램 사이에서 공유

#### Page Table
- 가상 페이지와 물리적 프레임 간의 매핑 정보를 저장하는 자료구조
- 가상 메모리는 페이지 단위로, 물리 메모리는 프레임 단위로 
- PTE
    - 가상 페이지와 물리 프레임 간 매핑 정보, 권한 등의 정보를 가짐 

#### Translation Lookaside Buffer (TLB)
- 페이지 테이블의 일부를 캐싱하여 주소 변환 속도 향상.
- TLB 미스 발생 시 페이지 테이블을 참조.

#### Page Fault
- 프로그램이 필요한 페이지가 물리 메모리에 없는 경우 발생
- 처리 과정
	1. 페이지 폴트 발생 시 운영체제가 디스크에서 해당 페이지를 물리 메모리에 로드
	2. 기존 페이지를 교체(Eviction)해야 하면, 페이지 교체 알고리즘에 따라 결정

#### Lazy Loading
- 필요한 시점에 데이터를 로드하는 기법
- 초기 로드 시간을 줄여주고, 메모리를 효율적으로 사용

#### Page Replacement Policy
- 물리 메모리가 가득 찬 경우, 어느 페이지를 교체할지 결정
- 주요 알고리즘
    - FIFO(First-In-First-Out): 가장 오래된 페이지 교체
    - LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 페이지 교체
    - LFU(Least Frequently Used): 사용 빈도가 가장 적은 페이지 교체

#### Anonymous page
- 특정 파일이나 디스크 데이터에 매핑되지 않은 페이지
- 메모리 상에서만 생성되고 유지되는 페이지
- 힙, 스택 등을 통한 동적 메모리 할당 시 생성
- 데이터 세그먼트도 해당됨
- 주로 0으로 초기화
    - 보안 문제
    - 새로 할당되는 동적 페이지를 0으로 초기화 하여 다른 프로그램에서 사용되는 데이터가 노출되지 않도록 함

#### Swap Disk
- 디스크 영역 중 가상 메모리로 사용되는 영역
- 물리 메모리가 부족할 때 임시로 데이터를 저장하는 용도로 사용
- 페이지 교체 알고리즘으로, 할당 가능한 프레임이 부족할 때, 덜 중요한 페이지를 스왑 디스크로 보내고 새로운 페이지를 해당 프레임에 할당
- 당연히 느림

#### File-backed Page
- 파일로부터 데이터를 읽어와 메모리 페이지에 매핑된 가상 메모리 페이지
- 페이지 폴트 발생 시 파일 데이터를 읽어 물리 메모리에 로드 
- 지연 로딩으로 메모리 사용 최소화하거나 수정된 데이터를 파일과 동기화 할 수도 있음

#### Direct Memory Access
- cpu를 거치지 않고 하드웨어 장치가 메모리에 직접 접근
- cpu 개입을 최소화하여 데이터 전송 속도를 높이고 cpu 부하를 줄임

---

## 퀴즈 정리

#### 페이지 테이블 접근 시 TLB가 어떻게 페이지 테이블의 성능을 향상시키는지 설명하고, TLB miss가 발생하면 시스템이 어떤 과정을 거쳐 메모리에 접근하는지 설명
- TLB는 자주 사용되는 주소 변환 정보를 빠르게 참조할 수 있도록 하는 캐시 메모리입니다.
- TLB에 원하는 주소 변환 정보가 있으면, 페이지 테이블을 참조하지 않고 바로 물리적 주소를 얻을 수 있어 성능이 향상됩니다.
- TLB miss일 때 시스템은 페이지 테이블을 조회하여 물리적 주소를 찾고, 이 정보를 TLB에 업데이트합니다.

#### 페이징 기법을 사용하는 메모리 관리 시스템에서, 페이지 프레임 수를 늘리는데도 page fault가 발생하는 빈도가 오히려 늘어나는 경우가 있습니다. 이를 Belady의 역설(Belady's Anomaly)이라고 하는데, 이런 현상이 발생하는 원인과 이를 방지하는 해결 방법에 대해 설명
- Belady’s Anomaly는 특히 FIFO(First-In, First-Out) 페이지 교체 알고리즘에서 관찰됩니다.
- 페이지 프레임의 수가 증가함에도 불구하고, FIFO 알고리즘은 새로운 페이지가 오래된 페이지보다 덜 필요할 수 있는 상황을 고려하지 않습니다. 이로 인해, 실제로는 자주 사용되는 페이지가 교체될 수 있고, 그 결과 페이지 폴트가 더 자주 발생합니다.
- 이를 해결하기 위한 방법으로는 더 진보된 페이지 교체 알고리즘을 사용하는 것입니다.
- LRU, LFU등의 알고리즘들은 페이지를 교체할 때 단순히 페이지의 로드 시간뿐만 아니라 사용 빈도나 최근 사용 기록을 고려합니다. 즉, Locality 개념에 기반한 제약을 가미하고, 교체/할당 정책을 보완하는 것이 해결방안이 될 수 있습니다.

#### 스레싱(Thrashing) 현상에 대해 설명
- 스레싱은 프로세스가 너무 자주 페이지를 교체하여 실제 유용한 작업보다 페이지 교체에 더 많은 시간을 소비하는 현상입니다. 이는 일반적으로 메모리가 포화 상태이고, 멀티태스킹 환경에서 너무 많은 프로세스가 동시에 실행될 때 발생합니다.

#### 운영체제가 anonymous page를 0으로 초기화하는 이유
- anonymous page는 프로세스에 의해 동적으로 할당되는 메모리 페이지로, 이전에 다른 프로세스에 의해 사용되었을 가능성이 있습니다. 이러한 페이지를 0으로 초기화하지 않으면, 새로운 프로세스가 이전 프로세스의 데이터에 접근할 수 있는 보안 취약점이 발생할 수 있습니다.
- 0으로 초기화하는 과정은 새로운 프로세스가 페이지를 처음 사용할 때'깨끗한' 상태, 즉 어떠한 이전 데이터도 포함하지 않는 상태로 시작할 수 있도록 보장합니다.

#### LRU
- [LRU](https://www.geeksforgeeks.org/program-for-least-recently-used-lru-page-replacement-algorithm/)

#### Clock Algorithm
- [clock algorithm 구현](https://gist.github.com/st-tran/8dd0d5ff677a08410066dbfb145f7ca4)
