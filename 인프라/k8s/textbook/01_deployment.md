# Pod, Deployment
- k8s는 컨테이너로 애플리케이션을 실행하지만, 직접 컨테이너를 다루지 않음
- 모든 컨테이너는 Pod에 속함
- Pod
    - k8s가 `컨테이너`를 관리하는 데 사용하는 `단위`
    - 컨테이너의 세부사항을 `추상화`
- 이런 방법으로 `자기수복형(self-healing)` 애플리케이션이나, `바람직한 상태(desired-state)` 워크플로가 가능해짐
- 파드는 `디플로이먼트(deployment)`로 `관리`될 수 있음
- 그리고 `명령행 도구`와 `YAML 정의 파일`로 애플리케이션을 `정의`하고 `관리`할 수 있음

## 1. 쿠버네티스는 어떻게 컨테이너를 `실행`하고 `관리`하는가
- __컨테이너__
    - 애플리케이션 구성 요소 하나를 실행하는 가상화된 환경
    - k8s는 이 컨테이너를 또 다른 가상환경인 `Pod`로 감싼다.
- __파드(Pod)란??__
    - `컴퓨팅 단위`
    - 클러스터를 이루는 `노드` 중 하나에서 실행
    - 쿠버네티스로 관리되는 `자신만의 가상 IP 주소` 가짐
        - 이 가상 IP로 가상 네트워크 상에 접속된 파드들과 통신을 주고 받을 수 있음
    - 하나의 pod에는 여러 개의 컨테이너를 포함할 수 있지만, `대게 하나`
    - `Pod 안에 있는 컨테이너들`은 같은 가상환경. 
        - 서로 네트워크 공유
        - localhost로 통신 가능
    - 실행
        - `kubectl run jm --image=jm-server`
- __왜 컨테이너를 직접 다루지 않고 Pod로 감쌌는지?__
    - _`추상화된 컨테이너???`_
    - __컨테이너를 직접 실행하는 것은 k8s가 아니다.__
        - k8s는 CRI라는 공통된 인터페이스로 container를 Pod로서 관리
        - 실제 container는 CRI를 구현한 Container Runtime에서 관리
        - k8s는 CRI를 통해 Container Runtime에 요청하면, 실제 컨테이너 실행을 포함한 관리 작업들은 Container Runtime이 처리
        - __Container Runtime 마다 처리 방법이 다르지만, k8s는 CRI를 통해 Pod라는 일반화된 방법으로 container를 관리__
    - 컨테이너가 사라지는건 일시적 문제
        - Pod는 그대로 있음
        - Pod의 상태에 맞게 Container는 복원됨
        - 이게 자기수복성
- Deployment
    - Pod 위에 또 다시 얹히는 추상화
- 네트워크 전달 방법
    - `kubectl port-forward {pod} {호스트포트}:{파드포트}`
    - 파드의 포트를 호스트 포트로 forward 시킴
- 파드는 원시 타입 리소스
    - 직접 실행할 일은 없다.
    - `컨트롤러 객체`를 만들어서 관리

## 2. `컨트롤러 객체`와 함께 `파드 실행`하기
- __Controller 객체__
    - 다른 리소스를 관리하는 쿠버네티스의 리소스
    - 쿠버네티스 API와 연동하여 `현재 상태를 감시`하다가 `바람직한 상태`와 차이가 생기면 이 `차이를 바로잡음`
    - 여러 가지 컨트롤러 객체가 존재
- __디플로이먼트(deployment)__
    - 파드를 주로 관리하는 컨트롤러 객체
    - 어떤 노드 문제 -> 디플로이먼트가 대체 파드를 다른 노드에 실행
    - 스케일링하고 싶으면 파드 수를 지정, 그럼 디플로이먼트가 여러 노드에 걸쳐 필요한 파드 수 만큼 파드 실행
    - 생성
        - `kubectl create deployment jm --image=jm-server`
- __파드를 직접 만들지 않는다.__
    - 디플로이먼트로 필요한 파드를 기술했을 뿐
    - 디플로이먼트는 쿠버네티스 API를 통해 기술한대로 Pod를 관리
- __디플로이먼트의 파드 추적 방법__
    - 모든 쿠버네티스 리소스는 키-값 쌍 형태의 레이블을 가짐 
    - __느슨한 결합__
        - 컨트롤러 객체는 레이블 셀렉터를 통해 자신이 관리하는 리소스인지 판단
        - 레이블 셀렉터는 컨트롤러 객체에 정의에 포함됨

## 3. 애플리케이션 `매니페스트`에 배포 정의하기
- JSON, YAML 모두 가능
    - 정식 포맷은 JSON이지만, 파일 하나에 더 많은 리소스를 정의할 수 있는 YAML을 더 많이 사용
- 뭐가 좋은데? 
    - 형상 관리 도구를 통해 버전 관리 가능
    - 다른 쿠버네티스 클러스터로 옮기더라도 동일한 배포 가능
    - 주석을 쓸 수 있는 것도 굳! - json은 주석을 못 씀
- 단일 파드 정의
    ```yaml
    apiVersion: v1 # 쿠버네티스 API 버전
    kind: Pod # 리소스 유형

    metadata:
        name: jm-server # Pod의 이름 -> 필수
        # 레이블은 필수는 아니다.

    # 리소스의 실제 정의 내용
    spec:
        containers: # 파드는 container를 정의해야 함
            - name: web
              image: jm-hub/jm-server
    ```
- 매네페스트는 `선언적`
    - 일일이 지시하는 명령형과 달리 최종 결과가 어떻게 되어야 하는지 알려줌
    - 과정은 따지지 않음
- 적용하기
    - `kubectl apply -f pod.yaml`
- Deployment 정의
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
        name: jm-server
    spec:
        # pod를 찾을 때 사용
        selector:
            matchLabels: # 셀렉터 유형은 이거 말고도 더 있음
                app: jm-server # 이 레이블이랑 일치하는 리소스를 관리한다.
        # pod를 만들 때 사용
        template:
            metadata:
                labels:
                    app: jm-server # 이 레이블이 selector에서 정의한 것과 같아야 한다.
            spec:
                containers:
                    - name: web
                      image: jm-hub/jm-server
    ```

## 4. 파드에서 `실행 중인 애플리케이션 접근`하기
- 실제 애플리케이션은 컨테이너 속에서 동작한다.
- 컨테이너 런타임에 따라 컨테이너 직접 접근을 허용하지 않을 수도 있다.
- 명령행 도구 사용해서 실행 중인 애플리케이션 접근하기
```bash
$ kubectl exec -it jm-server sh
```
- 로그 확인하기
```bash
$ kubectl logs --tail=2 jm-server
```
- 파드 속 파일 시스템 접근
```bash
$ kubectl cp {파드이름}:{컨테이너 내 파일 경로} {호스트 파일 경로}
```

## 5. 쿠버네티스의 `리소스 관리` 이해하기
- 컨트롤러 객체가 관리하는 리소스를 직접 제거하면, 컨트롤러가 다시 새로운 리소스를 생성한다.
- 컨트롤러 객체가 관리하는 리소스가 아니면, 삭제했을 때 그냥 사라진다.
- 리소스를 제거하기 위해선, 관리해주는 컨트롤러 객체도 함께 삭제해주어야 한다.
- 컨트롤러 객체 제거하기
    - `kubectl delete deploy --all`