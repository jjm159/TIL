# tiny한 웹 서버
- 간단한 웹서버

# Homework

#### 11.6 C
Inspect the output from Tiny to determine the version of HTTP your browser uses.
-> request line 확인
```
GET /home.html HTTP/1.1
```

#### 11.7

Extend Tiny so that it serves `MPG` video files. Check your work using a real browser.

![스크린샷 2024-10-27 오후 4.00.01](https://hackmd.io/_uploads/Sk6xSvie1l.png)
```c
else if (strstr(filename, ".mpg") || strstr(filename, ".mpeg"))
{
    strcpy(filetype, "video/mpeg");
}
else if (strstr(filename, ".mp4")) 
{
    strcpy(filetype, "video/mp4");
}
```
- get_filetype에 type 추가
- 크롬에서 mpg 실행이 안되어 mp4로 진행

##### 터미널로 동영상 다운로드 받는 법
```shell
curl -O {url.mp4} -#
# -# 붙이면 다운로드 현황 보여줌
```

#### 11.9
Modify Tiny so that when it serves static content, it copies the requested file to the connected descriptor using `malloc`, `rio_readn`, and `rio_writen`, instead of `mmap` and `rio_writen`.

##### `mmap` vs `malloc + read`
- mmap

##### 과제 의도
- mmap을 사용했을 때와, 파일 읽기 시스템 콜을 사용하여 메모리를 load하는 것의 차이를 이해하는 것이 아닐까?
- 성능적 이점이 있는지 확인 -> 시간 체크


- 기존 mmap 사용
```c
  srcfd = Open(filename, O_RDONLY, 0);
  srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);
  Close(srcfd);
  Rio_writen(fd, srcp, filesize);
  Munmap(srcp, filesize); 
```
```
Response headers:
HTTP/1.0 200 OK
Server: Tiny Web Server
Connection: close
Content-length: 1055736
Content-type: video/mp4

걸린 시간: 0.002595 
```

- malloc + read 사용

```c
  srcfd = Open(filename, O_RDONLY, 0);
  srcp = (char *) malloc(filesize); // 메모리를 할당 받고 
  rio_readn(srcfd, srcp, filesize); // 할당 받은 메모리에 복사
  Close(srcfd);
  Rio_writen(fd, srcp, filesize);
  free(srcp);
```

```
Response headers:
HTTP/1.0 200 OK
Server: Tiny Web Server
Connection: close
Content-length: 1055736
Content-type: video/mp4

걸린 시간: 0.002998
```

##### 큰 차이가 없는 이유
- 파일이 작아서
- 단순히 한 번 읽고 끝나는 경우라서
    - mmap은 데이터에 여러 번 접근해야 하는 경우 유리
- 운영체제의 read 최적화

##### mmap이 유의미 하려면?
- 매우 큰 파일을 부분적으로 자주 접근
    - `지연로딩`의 힘
    - 실제로 해당 데이터가 필요한 경우에만 페이지 단위로 파일의 부분만 메모리에 적재


#### 11.10
A. Write an HTML form for the CGI adder function in Figure 11.27. Your form should include `two text boxes` that users fill in with the two numbers to be added together. Your form should request content using the GET method.
- home.html 수정 
```html
<form action="cgi-bin/adder" method="GET">
    <label for="num1">Number 1:</label>
    <input type="number" id="num1" name="num1" required>
    <br><br>
    <label for="num2">Number 2:</label>
    <input type="number" id="num2" name="num2" required>
    <br><br>
    <button type="submit">Submit</button>
</form>
```

- adder.c 수정
```c
  /* Extract the two arguments */
  if ((buf = getenv("QUERY_STRING")) != NULL)
  {
    p = strchr(buf, '&');
    *p = '\0';
    sscanf(buf, "num1=%d", &n1);
    sscanf(p + 1, "num2=%d", &n2);
    // strcpy(arg1, buf);
    // strcpy(arg2, p + 1);
    // n1 = atoi(arg1);
    // n2 = atoi(arg2);
  }
```

B. Check your work by using a real browser to request the form from Tiny,
submit the filled-in form to Tiny, and then display the dynamic content generated by adder.

![스크린샷 2024-10-27 오후 7.07.51](https://hackmd.io/_uploads/rkrWWqieJe.png)

![스크린샷 2024-10-27 오후 7.07.29](https://hackmd.io/_uploads/rJbgZqseJl.png)

#### 11.11
Extend Tiny to support the HTTP HEAD method. Check your work using telnet as a Web client.

##### HEAD method
- 응답에 header만 담아 보낸다. 
- body 없음! 그래서 빠름
- 빠르게 서버 상태 조회하기 위해 사용
- 이와 유사하게 조회를 위해 사용하는 method로 option이 있다.
    - option은 endpoint가 어떤 메서드를 지원하는지 응답 헤더에 Allow로 응답

##### 처리
- doit에 추가
```c
if (strcasecmp(method, "GET") != 0 && strcasecmp(method, "HEAD"))
{
clienterror(fd, method, "501", "Not implemented", "Tiny does not implement this method");
return;
}
```
- serve_dynamic, serve_static에 추가
```c
  if (strcasecmp(method, "HEAD") == 0) 
  {
    return;
  }


```

---

# 트러블 슈팅
##### 우분투 포트포워딩
- iptables로 하면 안되고 nftables를 사용해야 함 
```bash

sudo apt install nftables

sudo nft add table ip nat
sudo nft add chain ip nat PREROUTING { type nat hook prerouting priority 0\; }

sudo nft add rule ip nat PREROUTING tcp dport 6000 redirect to :6000

# 체인 규칙 모두 삭제 
sudo nft flush chain ip nat PREROUTING

# 체인 자체 삭제
sudo nft delete chain ip nat PREROUTING

sudo nft list ruleset
```
##### 포트를 6000으로 했더니 브라우저에서 ERR_UNSAFE_PORT 에러 발생. 
- 브라우저에서 8080과 같은 8000번대 포트가 아니면 차단함.

---