# Java 백엔드 개발자 면접

## 1. 웹 서비스 구조와 운영체제 기술

#### 웹 서비스 구조 - 기본 구조

#### 웹 서비스 구조 - 확장 첫 번째

#### 웹 서비스 구조 - 확장 두 번째

#### 웹 서비스 구조 - 확장 세 번째

#### 운영체제 구조 - User mode와 kernel mode 그리고 JVM

- native application 개발 시에는 os, hw와 같은 플랫폼에 의존
    - jvm 자체는 os, hw에 의존하는 native app임
    - jvm에서 실행되는 java 프로그램은 플랫폼에 의존적이지 않음
- 동시성
    - 멀티 스레드와 비동기 입/출력은 다른 이야기
    - 비동기 입출력은 유저 프로그램이 입출력을 기다리지 않음. - 기다리지 않는다는게 비동기
    - 그래서 빠름!


#### 브라우저에 URL을 입력하면 일어나는 일들 5분이상 말하기
- 도메인 주소의 host 보고 dns 물어봄 - 처음에는 브라우저 프론트 프록시에 dns 캐시로, 없으면 dns 서버로 dns query
- dns로부터 ip를 획득, 이걸로 tcp/ip 연결 (http는 기본으로 tcp, 3.0은 udp)
- 연결 맺고 나면 (핸드 쉐이크 후), 요청을 보내고 받음
- 응답으로 받은 html, css, img 파일들을 브라우저가 렌더링 함
- dns 캐싱 함
- 리소스도 캐싱 함

##### dns
- root dns 전세계에 13대
- 내 도메인을 보고 com, org 등의 기관 중 하나에 요청
- ip 주소 리스트를 줌
- 도메인을 구매했다? 이 도메인의 아이피가 저 아이피임

##### 보안
- 7.7 DDoS 대란
    - hosts 파일을 변조
    - naver를 흉내낸 서버로 접속하게 만듬
    - 이에 속은 유저는 ip, password를 입력해서 탈취 당함

##### tcp 핸드쉐이크
- 3-Way Handshake 과정
    - 왜 3-Way Handshake가 필요할까?
    - 서버가 잘 살아 잇음을 확인 + 클라가, 서버가 살아있음을 잘 확인했음을 확인 - 이거까지 다 돼야 보장
- 4-Way Handshake(4단계 핸드셰이크)란?
    - 왜?
    - 양쪽이 데이터를 다 보냈는지 확인 
        - FIN, ACK를 서로 주고받아야 데이터 유실 없이 안전하게 종료 가능
    - 반쪽 종료(Half-Close) 지원
        - 한쪽은 데이터 전송을 종료, 반대쪽은 계속 보낼 수 있도록 설계
        - 클라가 먼저 연결 종료 요청을 보내고, 서버는 아직 남은 데이터를 클라에게 보낼 수 있음
    - 데이터 전송 보장
        - 바로 끊어버리면 아직 수신되지 않은 패킷이 손실될 위험
        - 모든 패킷이 안전하게 전송되었는지 확인 가능

---

## 2. Web server와 HTTP

#### HTTP 버전별 차이 (HTTP/2가 빠른 이유)
- http2가 압도적으로 빠름
- http1은 
    - 모든 리소스에 대해 tcp 연결을 모두 맺었음
- http1.1
    - 세션은 한 번 맺지만, 
    - 각 리소스를 앞에서부터 순차적으로 하나씩 받아와서 리소스가 많을 수록 모든 리소르를 받아오는 데 시간이 오래 걸림
- http2는
    - 모든 리소스를 frame 단위로 잘라서 동시에 보내도록 함
    - 중첩된 동시 전송 가수
    - 90% 더 빠름
    - Binary Framing - 병렬 동시 전송 가능
        - 헤더도, 바디도 frame 단위로 잘라서 패킷 보내듯 동시에 와다다 보냄
        - frame을 동시에 받고 완성시키기만 하면 됨
    - wait에 의한 지연 X
- 헤더 압축
- 그리고 3로 가면
    - tls 필수
    - tcp에서 udp로 바꿈
        - tcp는 혼잡제어, 흐름제어를 함
            - 상대방이 얼마나 잘 받고 있는지를 체크
            - 흐름제어
                - 수신자의 버퍼 오버플로우를 방지, 데이터 손실 막음
                - 수신 윈도우=
                    - 수신자가 "내가 처리할 수 있는 데이터는 RWND 만큼이야"라고 송신자에 알림
                - 슬라이딩 윈도우
                    - 정해진 윈도우 크기만큼만 송신
                    - 수신자가 데이터를 처리하고 나면, 윈도우 크기를 늘림
            - 혼잡제어
                - 네트워크 과부하 방지를 위해 송신 속도 조절
                - 도달이 늘어날수록 지수적으로 전송 크기를 늘림
                - 스레스홀드를 넘어가면 선형 증가 
                - 실패시(같은 패킷에 대해 중복된 ACK를 3번 이상 보냄) 절반으로 속도 늦춤
                - 다시 반복


#### IPS와 Inline 구조
- 실무에서 뭔가 안됐을 때, - 네트워크 보안 솔루션도 검토해봐야 함

- 네트워크 계층
    - osi 7 layer
        - User
            - application - l7 - http
            - presentation
            - session - ssl(tls) l5
            - 이 계층에서 WAF 작동
                - Application Proxy로 동작
                - nginx나 아파치
        - kernel
            - transport - l4
            - network - l3
            - 이 레벨에서 작동하는 네트워크 장치의 유형
                - inline 장치 - 공기 청정기 필터
                    - packet filtering, IPS
                    - 얘네들이 http 통신을 감시함
                    - 근데 https로 암호화가 되어 있으면 이 레벨에서 필터링이 안됨
                    - 그래서 User 레이어에서 WAF로 걸러줘야 함
                - out of path - sensor 역할
        - H/W 
            - data link 
            - physical - l1
- inline
    - invisible - 존재하지 않는 것 처럼 감춰져 있음. 티가 안남
- out of path
- ssl 인증서
    - web 서버에 설치?
    - 아닐 수 있음
    - IPS - 침입 방지 시스템 - 여기에 설치해야 할 수 있음
    - 경우에 따라서는 로드밸런서에 올라가기도 함
    - 인증서가 뭔지 잘 알고 있어야 함!

#### WAF와 Proxy 구조
- proxy
    - socket
    - 티가 안나는 inline과는 다르게 proxy는 직접 소켓으로 연결되어 동작함
    - 서버를 대신해서 자기가 직접 연결해서 서버인 것 처럼 동작함
- 입력
    - 서버는 모든 입력에 대해 신뢰하면 안된다.
    - 항상 검증을 해야 한다.
    - 이 때 가장 많이 사용하는 방법이 WAF
    - 프록시 형태로 방화벽이 입력을 걸러준다. 그렇게 웹 애플리케이션을 보호한다.
- 인증서
    - WAF proxy 서버에 배치 

#### SSL 인증서는 어디에 설치되나?
- SSL 인증서
    - 내가 접속한 사이트가 진짜 그 사이트가 맞는지
    - ssl 인증서를 통해 검증!
    - 내가 접속하려는 웹 사이트가 가짜가 아니라 진짜예요 라고 인증해주는 것
- PKI
    - Public Key Infrastructure
    - 여기서 말하는 퍼블릭 키
        - 비대칭키의 퍼블릭 키
        - 비대칭키 암호화 알고리즘 - RSA
- PKI 인증서
    - X.509 형식의 파일이 인증서 파일임
    - 인증서는 상대방이 누구인지만 검증
    - 인증서 내 정보들
        - user 정보
        - public key
            - 클라이언트가 세션키를 전송할 때 이 키를 사용해서 암호화 함
            - 서버는 인증서와 함께 받은 private key로 이를 복호화 하여 session key를 공유 받음
        - digital sign of CA(암호화된 hash 값)
            - CA의 Private key로 hash한 결과가 암호화되어 있음
    - 검증 과정에서 PC에 사전 배포된 CA Public key(기관 인증서에 포함)로 암호를 풀어 검증 가능
- 인증서 발급
    - 서버는 CA로부터 발급받은 인증서(public key)와 private key를 받아서, 인증서를 등록할 때 이 둘을 같이 올려놓음
- 주고 받는 데이터 자체는 대칭키를 이용
    - session key 라고 함
    - 이 키를 가지고 http 통신에서 주고 받는 데이터를 암호화 함
- 참고
    - CA - Certification Authority, 인증 기관
        - PCA의 하위 기관
        - 인증서 발급과 취소 등의 실질적인 업무를 하는 기관
        - yessign - 금융결제원, NCA 한국 전산원 등이 이에 속함. 상호 신뢰함.
    - RA - Registration Authority, 등록 기관
        - 사용자의 신분을 확인하고 CA 간 인터페이스를 제공하는 기관
    - PAA - Policy Approval Authorities, 과학 기술 정보 통신부
        - 공인인증서에 대한 정책 결정, 하위 기관의 정책을 승인하는 기관
        - 대한민국은 미래창조과학부가 담당
    - PCA - Policy Certification Authorities, 정책인증기관
        - RootCA를 발급하고 기본 정책을 수립하는 기관
        - 우리나라의 KISA(Korea Inforamtion Security Agency, 한국정보보호진흥원)이 여기에 해당
        - RootCA는 모든 인증서의 기초가 되는 인증서를 보유
        - 인증서에 포함된 공개키에 대응되는 개인키로 생성한 자체 서명 인증서를 사용
- SSL 인증서가 어디에 설치되어 있는지를 보면 서비스 구조를 파악할 대 도움이 될 것


## 3. WAS와 JVM

#### JVM 기본 구조

#### GC 원리

#### GC와 JVM에 대해 물은 의도는 따로 있다? 

## 4. 데이터베이스

#### 인덱싱을 하는 이유는 무엇일까?
- 데이터베이스 -> 자료구조
    - 자료를 구조화해서 집합화 한게 데이터베이스
    - 자료구조 알고 있는 지식들 읊으면 끝남
- 왜 함?
    - __검색 속도를 높이기 위해__
    - 컬럼에 적용
    - 주로 B-Tree 혹은 B+Tree 자료구조로 구현
        - M차 트리 - 하나의 노드에 여러개의 데이터 저장 가능 - 블록 단위로 한번에 크게 데이터를 읽는 디스크에 굳 - 디스크는 느려서 한번에 왓다갓다함
        - 인덱스 검색 속도는 B+Tree가 빠름 - 마지막 노드들을 연결리스트로 연결해놔서, 대신에 수정할 때 오버헤드 큼
    - 대규모 테이블에 적용하여 삽입, 수정, 삭제가 자주 발생하지 않은 경우에 활용
    - 인덱스가 있을 경우 검색속도 증가
        - where, range 검색, pagination 시 굳
    - 테이블에 없는 정보 검색 시 빠른 판단이 가능
- 2차 메모리 - SSD
    - File - 연속된 비트열
    - 선형 자료구조
    - 없는 정보 검색 시 최악의 시간 복잡도 O(N)
    - 인덱스를 걸어두면, 없는 데이터를 찾을 때 O(logN)
- __인덱싱에 따른 오버헤드__
    - 인덱스를 위한 메모리 추가 소모
    - 데이터 삭제 시 인덱스까지 수정하는 오버헤드
        - 추가로 수정하는 연산이 필요한 것!!
    - 잘못 사용하면 느려질 수 있음
        - 나이나 성별 같이 값의 range가 적은 컬럼인 경우, 인덱스를 읽고 나서 다시 많은 데이터를 조회해야 하기 때문에 비효율적
        - 범주형 데이터!!!는 쓰지 마~!!

###### 갑자기 file
- 파일은 데이터와 자원의 추상화
- 다양한 하드웨어 및 시스템 자원을 일관된 방식으로 접근할 수 있도록 하는 추상화 계층
- 스토리지, 메모리, 네트워크, 프로세스, 입출력 장치 등 하나의 공통된 인터페이스로 다룰 수 있도록 추상화한 게 파일

#### 트랜잭션에 대해 물어본다면...
- 데이터베이스는 복잡한 시스템
    - 동시에 접근하는 경우 생각
    - OS에 버금가는 복잡한 시스템임
- 트랜잭션
    - 일련의 작업이 모두 수행 또는 하나라도 실패시 취소될 수 있는 '작업의 논리적 단위'
    - 모든 절차에 대해 __원자성__ 이 보장되어야 함
    - TPS (Transaction per second)
        - 시스템 안정성 기준 지표
        - 트랜잭션이 초당 몇 번이나 발생해도 문제 없다
        - 이것을 고민했다는 말이 어필이 되어야 함
    - ACID 특성
        - 원자성 Atomicity
        - 일관성 Consistency
        - 격리성 Isolation
        - 지속성 Duration
- 트랜잭션과 동시성 이슈
    - Transaction의 과정
        - 데이터는 File 로 저장
        - Transaction이 일어나면, File의 사본을 메모리에 올려서 작업함
        - 작업이 모두 완료되면 그 때 commit을 통해 File에 반영
        - 만약 작업중에 뭔가 문제가 발생하면, 그냥 메모리에 올려놓은 데이터를 commit을 안하면 됨
        - 데이터베이스 내부가 이런식으로 되어 있다.
    - 동시성 관련 이슈
        - 커밋 완료 전 Read (Dirty read)
            - A가 commit 한 걸 반영하기 전에 B가 읽음
                - 문제가 될 수도 있고 아닐 수도 있음
        - 커밋 완료 전 Overwrite
            - A가 쓰고 커밋 전에, B가 가져가서 쓰고 커밋, 이상태에서 A 커밋
            - B가 커밋한건 아예 없어져 버림 
        - Read 중 데이터가 변경되는 경우
        - 변경한 데이터 유실 (Lost update)
- 트랜잭션 isolation level (격리 수준)
    - 동시에 실행되는 트랜잭션들이 서로에게 미치는 영향을 어느 정도로 제한할 것인지 결정
        - a Dirty Read → 커밋되지 않은 데이터를 읽음
        - b Non-Repeatable Read → 같은 데이터를 두 번 읽을 때 값이 변경됨
        - c Phantom Read → 트랜잭션 중 새로운 데이터가 삽입됨
    - READ UNCOMMITED
        - a,b,c 모두 발생 가능
        - 아직 커밋 안해도 읽을 수 있음
    - READ COMMITED
        - a 방지
        - 커밋되어야만 읽을 수 있음
    - REPEATABLE READ
        - a,b 방지
        - 트랜잭션 중에는 여러번 데이터를 읽어도 값이 변하지 않도록 보장함
            - 다른 트랜잭션에서 접근시 똑같은 값이 읽힌다는게 아니고, 
            - 이 작업을 처리하는 트랜잭션 안에서 그렇다는 말!
        - 성능과 정합성의 균형을 맞출 때 사용
            - 정합성 
                - 무결성 제약 조건을 항상 만족해야 함 - 모든 데이터가 항상!
                - A 데이터와 B 데이터가 똑같이 무결성을 만족해야 하는데, 아니면 정합성이 깨진 것
    - SERIALIZABLE
        - 완벽한 Transaction 동기화
        - 앞에 트랜잭션이 처리되어야 다음 트랜잭션 처리
        - 대신 처리 속도가 늦어짐
        - 금융 시스템에서 사용
- 면접
    - 원자성 보장되어야 하는 작업 단위
    - TPS를 가지고 성능쪽으로 대화의 주제를 이끌어 가도 좋고
    - 장애
        - 경험은 못해봤지만, 이렇게 부하를 줘봤더니 성능이 좋지 않더라
        - 또는 이론상 트랜잭션 처리시 동시성 관련 이슈가 있을 수 있다!
            - 커밋 전에 읽는다던가, 커밋 전에 덮어써진다던가 등등
        - 그렇다고 완전 동기화 하면 느려진다
            - 그래서 격리 수준을 둬서 적당히 타협을 하게 된다
                - 4가지 레벨이 있는 걸로 알고 있고 보통 2, 3 레벨을 쓰는 걸로 알고 있다.
                - mysql, mariaDB같은 innodb는 REPEATABLE READ 사용
                - 그 외 대 부분 READ COMMITTED
- SQL - 잘 알아야 함!!
    - 조인시 성능 저하 이유
    - 서브쿼리 시 성능 저하 이유
- APM 같은걸로 부하테스트 해보기를! 

#### DB 커넥션 풀의 용도와 필요를 묻는 숨은 의도?
- DB Connection pool 연결 대기 지연
    - 연결 자체도 성능에 영향
    - 그래서 pool을 만들어 미리 해놓음!!!
    - 평상시에는 문제 안되지만, 요청이 갑자기 몰리는 상황이 벌어졌을 때가 문제
    - DB pool이 부족할 경우 응답 시간이 튀는 현상 발생, 새 연결을 생성하는 시간 때문
    - pool에 있는 connection의 수가 Full이 되었을 때, 
        - DB connection 요청 대기 시간을 길게 설정하면 이 또한 장애 유형이 될 수 있음
        - 너무 오래 기다려서 응답이 너무 느려짐
    - 반대로 강제 회수도 적절치 않을 수 있음
        - 연결하던 것 중에 강제로 회수해서 요청에 대응하는 것도 문제
- 어설프게 거짓말 X
    - 글을 봤음
    - [참고!!!](https://engineering-skcc.github.io/cloud/tomcat/apache/DB-Pool-For-Event/)
    - 결국 성능 검증은 테스트가 중요!!! - 안해보고 완전히 예측은 불가능 - 툴을 사용해서 꼭 해보는게 중요
- 비슷한 상황을 만들어서 성능 테스트를 해보는게 베스트!!!


## 5. 운영과 보안

#### 온프레미스 환경에서 클라우드 전환 시 고려사항은 무엇일까?

#### XSS와 CSRF 공격을 막으려면 어떻게 해야 할까?

## 6. 당신이 넷플릭스 서비스를 디자인 한다면?

#### 서비스 기본 구조와 필수 고려사항 (최소한 이 정도)

#### 부하분산 기술

#### 망사용료 이슈

---

## 7. JPA

#### N+1 문제
- 뭔데?
    - 1 대 N 관계일 때,
    - 1이 N인 데이터 리스트를 조회할 때 발생
    - 1을 가져올 때 쿼리 한번, N을 가져올 때 또 다시 쿼리가 N개가 날아감
- 해결
    - fetch join
        - 한 번의 쿼리로 연관 데이터 조회
        - jpql로 한번에 가져오도록 함수 따로 만들어서 가져오기
    - EntityGraph
        - 특정 엔티티를 즉시 로딩하여 최적화
        - Query("SELECT 어쩌고 FROM 어쩌고")를 붙여 놓으면 한 번에 가져옴
    - batch_size 설정
        - IN 절을 사용하여 여러 개의 데이터 한 번에 조회
        - 해당 연관관계에 있는 리스트 위에 @BatchSize(size = M)으로 한번에 가져올 사이즈 설정하면,
        - N번 쿼리가 날아가지 않고, N/M 번 쿼리 날리게 됨

#### 연관관계 매핑이 안티패턴일 수 있음
- 실용주의 책에서 - 왜 연관관계 매핑을 사용하지 말라고 했는지 다시 확인!!
- 성능
    - 위에서 발생한 N+1 문제, 무한 재귀 문제 등 발생 가능
    - 우회해서 해결은 가능함
- 순환참조
    - 순환참조는 성능도 성능이지만, 의존성을 높임
    - 순환참조가 이뤄지면 해당 사이클에 포함된 모든 클래스가 하나의 컴포넌트가 되어 버림

#### 영속성 컨텍스트와 내부 구조
- 영속성 컨텍스트 
    - 1차 캐시
    - 데이터베이스와 애플리케이션 사이에서 객체의 상태를 유지하는 핵심 개념
    - 영속성 컨텍스트 덕분에 변경 감지(dirty checking), 1차 캐시, 지연 로딩, 트랜잭션 관리가 가능해짐
    - 트랜잭션 종료 까지 영속 상태의 엔티티를 유지, 변경 사항 자동 감지하여 데이터베이스 반영
- 동작방식
    - 

- Entity Map
    - PK를 기준으로 엔티티를 관리
    - 엔티티 ID를 key로 1차 캐시에 저장
    - 같은 엔티티를 여러 번 조회해도 동일한 객체 유지
        - PK를 기준으로 하나의 객체만 메모리에 유지한다는 말
    - 같은 트랜잭션 안에서는 어디에서 접근하고 변경하더라도, 동일한 객체 하나로 유지
- 영속화?
    - 영속성 컨텍스트에 등록(persist 호출 또는 find로 )
    - Entity Map에 데이터를 넣어 관리하겠다는,
    - 해당 트랜잭션 동안 변경 추적, 유일한 객체 유지 하겠하는 말
- 트랜잭션 충돌 관리
    - 낙관적 락
        - 트랜잭션 충돌이 발생하지 않는다고 가정하고 일단 데이터 변경 허용
        - 마지막에 커밋할 때 충돌 감지하고 해결
        - 데이터 조회시 락 안 검
        - 업데이트 할 때 버전 필드를 이용해서 충돌 감지
        - 업ㅂ데이트 시점에 버전이 변경되었다면 예외 발생
    - 비관적 락
        - 트랜잭션 시작할 때 데이터에 락을 걸어 다른 트랜잭션에서 데이터에 접근 못하게 함
        - 데이터 충돌이 자주 발생하는 환경에서 사용
    - 디폴트는 락을 사용하지 않는 것
    - [참고](https://jaehoney.tistory.com/159)

## 8. springboot

#### container, IoC

#### AOP

#### MVC 구조
