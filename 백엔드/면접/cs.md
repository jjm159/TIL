# CS 대비

out of memory
- out of range와 다름
- 메모리가 부족해지는 현상 - iOS 개발할 때 힙 제대로 반환 안되면 이런 문제 생겼음
- 순환참조, 강한 참조로 인한 메모리 누수 발생 시 out of memory 발생 가능

빌드 과정
- 전처리 -> 컴파일 -> 링크

png jpg
- png는 손실 X 대신에 많이 압축 X, jpg는 손실 있지만 많이 압축 가능
- png는 손실 압축 알고리즘(lossy compression algorithm)), jpg는 무손실 압축 알고리즘(Lossless compression algorithm)

가비지 컬렉션 동작 원리
- [참고](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
- 처음에 참조 카운트로 대답
- 추가로 main부터 탐색해서 접근이 안되는 객체가 있으면 수집한다고 함
- 이게 reachable 개념이었음!

단편화
- 사용하지 않는 메모리가 있는데도 메모리를 할당할 수 없는 상태 - 메모리가 파편화 되어 할당될 수 없는 상태
- 내부 단편화 - 할당된 메모리 블록 안에 메모리가 파편화되어 할당 불가인 상태 - 내부에 낭비
- 외부 단편화 - 할당된 메모리 블록들로 인해 블록 외부에 메모리가 파편화되어 할당 불가인 상태 - 외부에 낭비

페이지
- 블록 단위로 메모리를 할당하여, 연속적으로 할당하지 않더라도 메모리를 할당 가능하게 만들어서 외부 단편화 막음
- 내부 단편화는 여전히 존재
- 페이지 크기
    - 4KB라고 한다면, 
    - 총 2^12니까 32bit 시스템에서 12bit를 페이지 offset으로 사용,
    - 20bit는 페이지 개수!

multi level page table
- 단일 페이지 테이블을 사용하면 페이지 테이블 전체가 메모리에 있어야 함
- 
- 64비트 시스템에서는 주소 공간이 크기 때문에 보통 3~4단계 페이지 테이블을 사용
- 가상 주소 64비트 
    - → 9비트(레벨-4) + 9비트(레벨-3) + 9비트(레벨-2) + 9비트(레벨-1) + 12비트(오프셋)

TLB
- 페이지 테이블이 메모리에 존재하면, 실제 데이터 접근까지 메모리에 두 번 접근해야 함
- 메모리에서 한번 가져온 페이지 테이블 엔트리는 TLB에 저장하는데, 
- TLB는 Translation Lookaside Buffer로, 
    - 이는 가상 주소(virtual address)를 물리 주소(physical address)로 변환(Translation)하는 과정에서
    - 빠르게 조회(Lookaside)를 수행하는 캐시(Buffer)를 의미
- 물리 메모리의 프레임 넘버를 확인하기 위해 메모리에 있는 페이지 테이블에 접근하기 전에,
- CPU MMU에 포함되어 있음
    - MMU는 가상주소 -> 물리주소 변환해주는 하드웨어 모듈
    - CPU는 명령어로부터 들어온 가상 메모리 주소를 MMU에 전달해주고, MMU는 물리 메모리를 반환함
    - MMU는 TLB를 가지고 있고, 여기에 있으면 바로 반환, 없으면 메모리에서 페이지 테이블 조회 후 반환
- 내 추가 질문 
    - 컨텍스트 스위칭할 때 TLB도 바뀌나? 그럼 PCB에 TLB 정보도 저장되나?
        - TLB도 바뀜
        - PCB에 저장되지 않음. CPU마다 다른데, 프로세스마다 TLB를 따로두는 것도 있고 그냥 날려버리는 것도 있음

메모리를 할당(라이브러리 함수 말고 시스템콜!)
- 시스템 콜
    - sbrk()
        - 힙 영역을 확장하는 방식으로 메모리를 할당 받아 옴트
        - 힙 중간을 해제할 수 없음. 확장하고 줄이는 것만 가능함
        - sbrk의 단점
            - 힙 영역의 중간 부분만 해제 불가
            - 전체 프로세스의 힙을 변경하여 여러 스레드가 동시에 사용하면 충돌 가능
            - 해제 안하면 사용하지 않는 메모리가 늘어나 메모리 단편화 문제 발생
    - mmap, unmap
        - 메모리를 디스크에 있는 데이터에 직접 매핑하여 할당
            - 가상 메모리 공간에서 새로운 페이지를 매핑하여 메모리를 할당
            - 힙과 관계 없이 별도의 메모리 블록을 생성할 수 있음
            - 개별적으로 할당 및 해제(munmap()) 가능
        - 디스크에 없더라도, 새로운 메모리를 직접 할당
        - 우선 가상메모리에서 페이지를 할당하고, 실제 접근하여 page fault가 날 때 물리메모리를 매핑
            - 그래서 read보다 빠르고 효율적임
- 라이브러리 함수 - heap 메모리 할당
    - malloc은 시스템콜이 아니고 라이브러리 함수임
    - malloc는 sbrk, mmap 시스템콜을 호출해서 메모리를 할당 받음
    - 내부적으로 heap 메모리 풀 가지고 있고, 부족할 때만 sbrk나 mmap으로 메모리를 추가로 가져옴
        - 작은 메모리는 sbrk로 큰 메모리는 mmap으로
    - 정글에서 구현한게 이거임!!!
- 함수 호출에 의한 메모리 할당
    - 함수를 호출하면 stack이 늘었다 줄었다 하면서 page를 요구하게 됨
    - stack에 page가 아직 할당되지 않아서 page fault가 나면,
    - 이 때도 mmap으로 새롭게 anonymous page를 할당 받아옴

anonymous page
- page의 유형 중 하나
- 파일과 연결되지 않고, 물리 메모리에서만 존재하는 페이지

링커가 뭐임?
- 컴파일을 통해 재배치 가능 목적 파일이 생성
- 링커가 이 파일들을 링킹을 통해 실행 가능 파일로 만들어줌
- 이건 기본적으로 정적 링킹! 컴파일 시점에 모든 목적 파일이 하나의 실행 가능 파일에 링킹 됨
- 동적으로 런타임에 링킹 되는 경우도 있음. 이를 동적 링킹
- 동적 라이브러리
    - 여러 프로그램이 함께 사용하는 경우
    - .so 파일
    - 런타임에 연결되어, 로딩이 느릴 수 있고 런타임 에러 가능성 존재
    
예외
- 인터럽트, 트랩(시스템콜), 예외, 중단
- 인터럽트
    - 외부 장치에 의해 실행 흐름이 커널로 넘어옴
    - 비동기적으로 일어남
- 트랩
    - 소프트웨어의 실행 코드로부터 제어권이 커널로 넘어옴
    - 동기적 실행