# 2. Basic
- make project
- make java project
- 외부 라이브러리 의존성 해결하기
- Build phase
- gradle Daemon

---

### make project
#### 1. 프로젝트 생성
```bash
gradle init
```
- 그레이들 프로젝트 셋업
- `basic` 선택 -> name 설정(현재 디렉터리가 디폴트) -> groovy -> generate build new APIs 어쩌고(No! 이게 디폴트)
- 생성 완료
├── build.gradle
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
- wrapper
    - 현재 그레이들 init했을 때 버전 정보를 담고 있음
- gradlew
    - 쉘 스크립트
- settings.gradle
    - 프로젝트 네임
    - 서브 모듈 네임
- build.gradle
    - 빌드 설정 파일 작성될 곳

#### 2. task 실행
```bash
gradle tasks --all
```
- 현재 프로젝트 내에서 사용 가능한 모든 gradle task 출력

#### 3. 실행
```bash
gradle firstTask # gradle fT 와 같음
```
- gradle {task 이름}

#### 4. build.gradle스크립트 분석
```groovy
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.10.2/samples
 */
println "Start Configuration..."
task firstTask { // task 정의 
    println "Hello World"
    doFirst() { // task의 여러 action 중에 젤 먼저 시작
        println "First action!!"
    }

    doLast() { // task의 여러 action 중에 젤 나중에 시작
        println "Last action!!"
    }
}

task secondTask {
    doFirst() {
        println "First action in secondTask"
    }

    doLast() {
        println "Last action in secondTask"
    }
}
println "End Configuration..."

```
- gradle firstTask 를 실행하면 
```
> Configure project :
Start Configuration...
Hello World
End Configuration...

> Task :firstTask
First action!!
Last action!!
```

#### 5. gradlew
- 전체 실행할 때 사용될 스크립트
- `./gradlew` 로 실행

---

### make java project
#### 1. 프로젝트 생성
- `gradle init`으로 생성 
    - application 선택
    - java 선택
    - single application project 선택
    - groovy
    - junit4

#### 2. 프로젝트 구조
.
├── app
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── org
│       │           └── example
│       │               └── App.java
│       └── test
│           └── java
│               └── org
│                   └── example
│                       └── AppTest.java
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
- `build.gradle`
    - app 밑으로 들어감 
    - plugins
        - id 'application' 추가
        - gradle tasks --all 하면 엄청 많은 것들이 나오는데, 이게 다 플러그인의 task들임
    - application
        - mainClass = 'org.example.App'
            - 메인 클래스 설정
            - 이게 있어야 build, compile, run 태스크를 실행할 수 있음
- `setting.gradle`
    - plugin 추가됨
    - include('app')
        - java 루트 디렉터리 이름. 이거 봐꾸고 루트 디렉터리 이름도 바꾸면 쉽게 바뀜
    - rootProject.name과 include에 사용된 네임이 같을 필요는 없다.

#### 3. 실행해보기
- `gradle compileJava`
    - build라는 폴더가 생성됨
        - App.class 파일 생성
- `gradle run`
    - 체크썸 확인해서 컴파일도 실행
    - main class가 실행됨!
- `gradle jar`
    - build 하위에 jar 파일 생성됨
- `gradle test`
    - build 하위에 report 파일 생성됨
        - index.html 실행하면 결과 확인 가능
- `build clean`
    - build 모두 삭제

---

### 외부 라이브러리 의존성 해결하기
- build.gradle에 dependencies에 추가
- 버전을 명시하지 않았을 때 버전 확인 방법
    - gradle/libs.versions.toml 파일에 다운로드 한 라이브러리에 대한 버전이 명시되어 있다.
- 어디에 있는가?
    - ./gradle에서 확인 가능

---

### 빌드 단계 (Build Phases)
#### 1. Initialization
- 어떤 프로젝트를 빌드할지
- 멀티 프로젝트인 경우, 해당 프로젝트와 관련된 모든 서브 프로젝트들을 식별함
- settings.gradle을 보고 프로젝트의 hierarchy를 구성하고 서브 프로젝트들을 포함한다.
- Gradle이 찾아낸 project 각각 하나의 `Project Object`가 생성된다.

#### 2. Configuration
- 어떤 task가 실행되어야 하는지 결정
    - task 그래프를 보고 결정
- task들 간의 의존 관계를 파악하고 properties를 구성함
- 여기는 그래프를 만들어서 어떤 task가 먼저 실행되어야 하는지 결정할 뿐 `실행은 안함`
- 사이클이 생기면 안됨

#### 3. Execution
- task들을 `실행`
- 이 결과로 여러 빌드 `결과물들이 생성`됨

#### 추가
- Task Avoidance
    - 체크섬 확인해서, 캐시된 건 더 이상 실행하지 않음
- Build Lifecycle
    - 이 3단계는 build가 수행되는 매번 반복된다.

#### 확인 
- gradle tasks --all
    - Configuration만 실행됨
- gradle fT
    - firstTask가 실행됨

---

### Gradle Daemon
- Gradle의 빌드를 더 빠르게 실행하기 위해 백그라운드에서 실행되는 장기 실행 프로세스(JVM으로 돌아가는)
- 특징
    - 백그라운드 프로세스
        - 시작 후 종료되지 않고 백그라운드에서 대기 상태로 유지
        - 빌드 요청이 오면 즉시 실행 시작
    - 빌드 캐싱
        - 이전 빌드에서 생성된 캐시 데이터를 재사용
        - 종속성 및 빌드 설정을 메모리에 유지, 빌드 실행을 더 빠르게!
    - JVM 재활용
        - jvm을 재실행할 필요 없이 이전 jvm 재활용
    - 자동 종료
        - 일정 시간이 지나면 자동 종료(보통 3시간)
- 활성화
    - 기본은 활성화
        - 그냥 gradle build 만 해도 --daemon으로 실행하게 된다.
    - 필요에 따라 비활성화할 수 있다.
- 명령 알아보기
    - `gradle build --daemon`
        - daemon 사용해서 빌드 시작
    - `gradle --stop`
        - daemon 중지
        - 빌드를 하고 있지 않은데도 리소스 많이 사용? 이럴 때 사용
    - `gradle build --no-daemon`
        - daemon 사용 안하고 바로 빌드하고 끝내겠다!
    - `gradle --status`
        - daemon이 실행되고 있는지 등의 상태 확인
- Lifecycle and Management
    - 사용 안하면 3시간 뒤 자동으로 꺼지도록(stop) 세팅되어 있음
    - --status 로 상태 확인 가능
- Troubleshooting and Considerations
    - Memory Management
        - jvm으로 돌아가기 때문에, 메모리 문제 생기면 jvm 설정을 추가하면 된다.
            - `org.gradle.jvmargs=-Xmx2g`
                - `-Xmx`는 max heap size 설정 옵션
        - `gradle.properties`에서 설정 가능
            - user-level 위치
                - `~/.gradle/gradle.properties`
            - project-level 위치
                - `project_root/gradle.properties`
        - 이외에도 `Gradle Properties`에 대해 gradle 공식 문서에서 설명 나와 있음

---

## 의문

### gradlew는 왜 있는걸까? (gradle wrapper)
- gradle 설치 없어도 어떤 환경에서도 실행 가능
- 일관성 보장 - gradle 버전 일관
- 모두가 동일한 빌드 환경으로 개발
    - gradle init을 한 환경에서의 gradle 버전으로 gradlew가 생성
    - 이 gradle 환경을 그대로 다른 사람들도 사용해서 실행
- 플랫폼 독립
    - 윈도우에서는 gradlew.bat
    - 맥, 리눅스에서는 gradlew
- [Gradle Wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper_basics.html#gradle_wrapper_basics)
    - 공식문서에서는 Gradle Wrapper를 사용하기를 highly encouraged 하고 있음
