# 멀티 스레드 스케줄링

[리눅스가 스레드와 프로세스 스케줄링을 처리하는 방법](https://www.it-swarm.dev/ko/linux/%EB%A6%AC%EB%88%85%EC%8A%A4%EA%B0%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/941066225/)

멀티 프로세스?멀티 스레드? → 스케줄링은 프로세스와 스레드를 구분하지 않는다.  그래서 일반적인 스케줄링 방법에 대해 정리 했다!

### 스케줄링에서 중요한 두 가지 지표

- `반환 시간(turnaround time)` - < 작업이 완료된 시각 - 작업이 시스템에 도착한 시각 >
    
    → 스케줄링의 대상이 되는 작업들의 작업 완료 시간이 얼마나 걸렸는지를 측정한다. 프로그램이 얼마나 빠르게 수행되었는지, 성능을 알려준다. 
    
- `응담시간(response time)` - < 처음 스케줄 시작 시각 - 작업 도착 시각 >
    
    → 프로그램이 스케줄러의 대상이 된 후 얼만큼의 시간이 지나서야 실행이 시작되었는지를 측정한다. 프로그램에 어떤 조작을 가하거나 프로그램을 실행시켰을 때, 얼마나 기다려야 프로그램이 반응하고 실행되는지에 대한 지표다.

### 비선점형 스케줄링( Non-preemptive scheduling )

→ 작업이 끝나거나 IO 요청으로 스스로 작업을 끝내기 전까지 CPU를 독점한다. 

→ 반환 시간이 좋지만 응답 시간이 좋지 못하다. 

`선입선출 FIFO` - 가장 단순한 비선점형 스케줄링 알고리즘이다. 작업이 시스템에 도착한 순서대로 실행한다. `Convoy Effect`(편의점에 커피 사러 갔는데, 내 앞에 거의 10만원 어치 쇼핑을 해버린 사람이 계산 중인 그런 상황)에 취약하다. 

`최단 작업 우선 SJF` ( Shortest Job First ) - 작업들이 동시에 도착할 경우, 가장 실행 시간이 짧은 작업이 우선 실행된다. 반환 시간만 고려하면 가장 우수한 알고리즘이다. 하지만  작업들이 동시에 도착한다고 보장할 수 없다. 그리고 역시 Convoy Effect에 취약하다.

`최소 잔여 시간 우선` `STCF`(Shortest Time-to-Completion First) - SJF를 보완한 스케줄링 알고리즘이다. 언제든 새로운 작업이 들어오면, 그 때 남아 있는 실행 시간들을 계산하여 다시 순서를 배정하고 실행한다. SJF가 동시에 도착한 경우 반환시간에서 가장 좋았 듯, STCF도 반환 시간의 측면에서 가장 좋은 알고리즘이다. 

### 선점형 스케줄링 ( Preemptive scheduling )

→ 다른 작업이 CPU에서 실행 중이어도, CPU 소유권을 가져올 수 있다. 

→ 응답 시간은 좋지만 반환 시간이 좋지 못하다. 

`라운드 로빈(Round Robin, RR)` -  다른 말로 타임 슬라이싱이라고도 한다. 작업이 모두 끝날 때 까지 기다리지 않고 정해진 시간만큼 실행하고 다음 차례의 작업을 실행 시키는 알고리즘이다. 아무리 긴 작업 시간을 가지고 있어도 정해진 시간이 되면 CPU 소유권을 내놓기 때문에 일정한 응답시간을 가지게 된다. 

이 때 '정해진 시간'을 Time Slice 또는 Scheduling quantum 이라고 한다.  이 타임 슬라이스가 너무 짧으면 문맥 교환 비용에 대한 부담감이 높아지고, 너무 길면 응답시간이 나빠진다. 그리고 타임 슬라이스는 타이머 인터럽트 주기의 배수여야 한다. 

응답시간이라는 장점을 얻은 대신에 반환 시간은 최악이 되었다. 

이런 알고리즘들은, 반환 시간이나 응답 시간 중 하나만 좋다. 이 두 가지 지표를 모두 잡기 위해 탄생한 멀티 레벨 피드백 큐에 대해서는 아래 학습하기에서 다루어 본다.


### 맥 OS에서 스케줄링
[Scheduling (computing)](https://en.wikipedia.org/wiki/Scheduling_(computing))

macOS uses a multilevel feedback queue, with four priority bands for threads – normal, system high priority, kernel mode only, and real-time.[13] Threads are scheduled preemptively; macOS also supports cooperatively scheduled threads in its implementation of the Thread Manager in Carbon.

### 맥 os는 MLFQ를 사용한다고 한다. 이 멀티 레벨 우선순위 큐를 정리하며 오늘 만든 것과 어떤 차이점이 있는지 살펴보았다!

### MLFQ의 다섯 가지 규칙

1. 우선순위가 더 높은 작업이 먼저 실행된다. - 이를 위해 사용되는 것이 멀티 레벨 큐다. 큐를 여러 개 준비하여 각각의 큐가 다른 우선 순위를 가지도록 한다. 더 높은 우선순위를 가진 큐에 있는 작업이 먼저 실해되는 것이다. 이 때 같은 같은 큐에 배정되어 같은 우선 순위를 가지게 되는 경우가 있는데 이는 다음 규칙으로 해결한다. 
2. 우선 순위가 같은 경우, 즉 같은 레벨의 큐에 존재하는 경우에는 RR방식으로 실행된다. Time Slice를 통해 공정하게 시간을 배분한다. → 오늘 미션에서 만들었던 프로그램이 RR을 사용하였다. 
3. 처음에는 모든 작업들이 가장 높은 우선 순위를 가지는 큐에 배정된다. 
4. Time Slice를 모두 소진하게 되면, 이를 오래 걸리는 작업으로 인식하여 우선순위를 낮춘다. 이 때 Time Slice가 다 소모되기 전에 작업이 끝나면, 다음 그 작업이 실행될 때 남은 Time Slice를 이어서 쓰게 된다. 만약 Time Slice가 새로 작업이 시작할 때 마다 꽉 채워진 상태로 주어진다면, 일부러 Time Slice가 끝나기 전에 작업을 끝내는 방식으로 최상위 우선 순위를 유지하려는 악용의 소지가 있다. 그래서 Time Slice가 남은 채로 작업이 종료되면, 이 시간을 다음 작업 시작시 이어 받아 사용하게 된다. 
5. 일정 주기 S가 지난 후, 모든 작업들을 다시 최상위 큐로 이동시킨다. 이것은 `기아 상태`(Starvation, 스똴-붸이션)을 해결하기 위함이다. 만약 5번째 규칙을 적용하지 않는다면, 짧은 실행 시간을 가진 작업만 계속 실행될 것이다. 그래서 긴 실행 시간이 필요한 작업들은 우선순위 맨 아래에 남게 되어 실행되지 못할 것이다. 이를 기아 상태 라고 한다. 5번째 규칙에 의해 일정 시간 후 모든 작업들이 다시 최상위 큐로 올라가게 되면, 기아 상태에 있던 작업들도 실행될 기회를 얻게 된다.



---

### 참고
[비선점 or 선점형 스케줄링](https://m.blog.naver.com/PostView.nhn?blogId=rlaauddlf200&logNo=30141162460&proxyReferer=https:%2F%2Fwww.google.com%2F)

[Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)

---

