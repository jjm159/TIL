# GMP 모델
- Go 런타임의 스케줄링 모델
- 고루틴(Goroutine)을 운영체제(OS) 스레드 위에서 효율적으로 실행하기 위한 구조

## 세 가지 요소
- G (Goroutine, 고루틴) → 실행할 코드를 담고 있는 논리적인 작업 단위
- M (Machine, OS Thread) → 실제로 CPU에서 실행되는 운영체제(OS) 스레드
- P (Processor, 가상 프로세서) → 고루틴을 실행할 수 있는 실행 환경 (M과 G를 연결하는 중간 계층)
- Go 런타임은 M:N 스케줄링(M OS Thread에 N Goroutine을 매핑하는 방식)을 사용하여, 
    - 적은 수의 OS 스레드로 수천 개의 고루틴을 효율적으로 실행

## GMP 모델의 구조
- Go 런타임이 고루틴을 실행하는 구조
    - [ 고루틴(G) ] → [ P(Processor) ] → [ OS 스레드(M) ] → [ CPU ]
- 고루틴은 OS 스레드와 직접 1:1로 매핑되지 않고, P를 통해 OS 스레드와 매핑됨
- 고루틴(G): Go에서 실행되는 가벼운 작업 단위
- 프로세서(P): 고루틴이 실행될 수 있는 실행 컨텍스트 (OS 스레드와 연결됨)
- OS 스레드(M): 운영체제가 관리하는 실제 실행 단위
- CPU: OS 스레드가 실행되는 물리적인 하드웨어
- 🔹 P는 한 번에 하나의 M만 가질 수 있음
- 🔹 M은 P 없이 직접 실행되지 않음
- 🔹 G는 P에 붙어서 실행됨 (즉, P가 없으면 G는 실행될 수 없음)

## Go의 M:N 스케줄링 방식 (Goroutine이 OS 스레드와 매핑되는 방식)
- Go는 고루틴을 운영체제 스레드와 직접 1:1로 매핑하는 대신, M:N 스케줄링을 사용
    - 1:1 모델
        - 하나의 고루틴(G)당 하나의 OS 스레드(M) 사용
        - 스레드 생성 비용이 크고, 컨텍스트 스위칭 비용 발생
    - M:1 모델
        - 모든 고루틴을 하나의 OS 스레드에서 실행
        - 병렬 실행 불가 (멀티코어 활용 못 함)
    - M:N 모델 (Go 런타임 사용)
        - 여러 개의 고루틴을 여러 개의 OS 스레드에서 실행
        - 병렬 실행 가능 + 스레드 개수를 최소화

## 동작 방식
- (1) 고루틴이 생성될 때
    ```go
    go func() {
        fmt.Println("Hello, Goroutine!")
    }()
    ```
    - 새로운 **고루틴(G1)**이 생성되면, P의 **로컬 큐(Local Run Queue)**에 추가됨
    - P는 G1을 선택해서 실행할 **OS 스레드(M1)**에 매핑시킴.
- (2) 고루틴이 너무 많으면 전역 큐(Global Queue)로 이동
    - 고루틴이 많아지면 P의 로컬 큐가 꽉 참
    - 이때 일부 고루틴(G5, G6 등)을 **전역 큐(Global Queue)**로 이동시켜 다른 P에서도 실행할 수 있게 함
- (3) 블로킹 시스템 호출(syscall)이 발생하면 M을 교체
    - 고루틴이 네트워크 요청이나 파일 I/O 같은 **블로킹 시스템 호출(syscall)**을 실행하면
    - OS 스레드(M)는 블로킹돼서 다른 작업을 수행할 수 없음
        - OS 입장에서 go 런타임은 하나의 프로세스임
    - Go는 블로킹 호출이 발생해도 전체 프로그램이 멈추지 않고 다른 고루틴을 실행할 수 있도록 M을 교체하는 방식으로 최적화
        - 기존 OS 스레드(M1)는 블로킹 상태가 됨
        - P는 새로운 OS 스레드(M2)를 가져와서 다른 고루틴을 실행함
        - 블로킹된 M1이 작업을 끝내면 다시 P에 반환

## Go의 GMP 모델이 가지는 장점
- 수천 개의 고루틴을 몇 개의 OS 스레드만으로 관리 가능 (효율적인 멀티스레딩)
- P(Processors)를 통해 OS 스레드와 고루틴을 효과적으로 매핑 → 실행 성능 향상
- 고루틴끼리 context switch 비용이 적고, 실행 비용이 낮음
- 블로킹 호출을 해도 다른 고루틴이 계속 실행 가능 → 동시성 처리 최적화

## GMP 모델이 Go의 강력한 동시성의 핵심
1.	GMP 모델은 M:N 스케줄링을 사용하여 수천 개의 고루틴을 적은 수의 OS 스레드로 실행할 수 있도록 최적화됨.
2.	고루틴이 실행될 때 P(Processor) 내에서 관리되며, OS 스레드(M)와 직접 1:1로 연결되지 않음.
3.	블로킹 호출(syscall)이 발생해도 새로운 OS 스레드를 생성하여 실행을 멈추지 않음.
4.	Go는 이러한 GMP 모델 덕분에, 개발자가 직접 스레드를 관리하지 않아도 매우 효율적인 동시성 프로그래밍을 할 수 있음. 

## P
- 하나의 P에는 하나의 M만 연결
- P는 **고루틴을 실행할 수 있는 논리적인 실행 컨텍스트(가상 프로세서)**, **“논리적인 실행 단위”**
- P와 CPU 코어의 관계
    - Go 프로그램을 실행할 때 GOMAXPROCS 값에 따라 P의 개수가 결정됨
    - 기본적으로 GOMAXPROCS는 물리적인 CPU 코어 개수와 동일한 값으로 설정됨
    - 하지만, 개발자가 runtime.GOMAXPROCS(n)을 사용해서 P의 개수를 변경할 수도 있음
- P(Processor)와 M(OS Thread)의 관계
    - Go의 GMP 모델에서 P(Processor)는 하나의 M(OS Thread)만을 실행
    - 즉, P는 한 번에 하나의 OS 스레드만 사용할 수 있으며, 여러 개의 M을 동시에 가질 수 없음
    - 하지만 M이 블로킹 상태(syscall)로 들어가게 되면
        - Go 런타임은 새로운 M을 생성하여 P와 연결
- Go의 M:N 스케줄링과 P의 역할
    - 여러 개의 고루틴(G)은 P의 로컬 큐에 저장됨.
    - P가 G를 선택하여 M(OS Thread) 위에서 실행함.
    - 하나의 P는 하나의 M만 실행할 수 있음.
    - P의 개수(GOMAXPROCS)에 따라 동시에 실행 가능한 고루틴의 개수가 결정됨.
