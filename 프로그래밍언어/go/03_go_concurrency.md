# Go 동시성 프로그래밍

## 고루틴
- 경량 스레드
- Go언어에서 기본으로 제공해주는 내장 기능
- 함수나 명령을 동시에 수행할 때 사용

## 경량 스레드 (Green Thread)?
- 커널이 아니라 사용자 공간(User Space)에서 관리되는 스레드
- 운영체제가 직접 관리하지 않고, 사용자 레벨 라이브러리 또는 런타임에서 스케줄링을 담당
    - 운영체제의 스케줄링과 별개로 프로세스 내에서 스케줄링을 한다!!!
    - 고루틴 코드를 짜면, 컴파일될 때, 알아서 이 스케줄링 코드들이 생성되어 실행파일에 포함됨!
- 특징
    - 운영체제 커널이 아닌 사용자 공간에서 스케줄링이 이루어짐.
    - 스레드 전환(Context Switch)이 빠름 (커널 개입 없음).
    - 커널 스레드보다 생성/소멸 비용이 낮음.
    - 하나의 Green Thread가 블로킹되면 전체 프로세스가 멈춤.

## 컨텍스트 스위칭 비용
- 스레드를 전환하려면 현재 상태를 보관하고 복원하는 작업이 필요. 이게 컨텍스트 스위칭
- 너무 많은 스레드를 생성하면 성능이 저하됨
- 보통 코어 두 배 이상 만들면 스위칭 비용이 많이 발생한다고 함
- Go에서는 할당 받은 스레드 안에서 컨텍스트 스위칭을 함.
    - 실제 코어가 스레드를 변경하는 게 아님.
    - 그래서 컨텍스트 스위칭 비용이 들지 않음
- 컨텍스트 스위칭 비용이 들지 않기 때문에 수천 수백개의 고루틴을 마음껏 만들어 쓸 수 있음

## 이렇게 좋은데 왜 운영체제는 경량스레드를 지원해주지 않을까?
- 사용자 레벨 스레드(경량 스레드)의 한계
    - __블로킹 호출 문제__
        - 사용자 레벨 스레드는 커널에서 볼 때는 `하나의 프로세스`로만 인식
        - 따라서 이 프로세스 내 어느 한 스레드가 디스크 I/O 등 블로킹 시스템 콜을 호출하면,
        - OS 입장에선 그 프로세스 자체가 잠깐 멈춰있는 것처럼 인식
        - 결과: 여러 사용자 레벨 스레드가 있어도, 한 스레드의 블로킹 때문에 모두 함께 대기하는 상황이 생길 수 있음.
    - `이중 스케줄링(Two-level Scheduling)`에 따른 복잡성
        - 사용자 레벨 스레드를 관리하는 라이브러리 스케줄러와, 커널이 CPU 시간을 분배하는 커널 스케줄러가 따로 존재함
        - 사용자 레벨에서 “이 스레드(A)를 가장 우선 실행하고 싶다”고 해도, 커널은 “해당 프로세스 중 어떤 스레드가 우선순위가 높은지” 알 방법이 없음
        - 결과: 사용자 레벨과 커널 레벨 스케줄링이 따로 놀아, 최적화가 쉽지 않고 구현이 복잡해짐.
            - 예: 사용자 레벨에서 A 스레드를 우선순위 높게 배정해도, 커널은 전혀 그 정보를 모른 채 프로세스 단위로만 CPU를 배분
    - `커널 차원 문맥 전환 활용` 어려움
        - 커널 레벨 스레드는 OS가 스레드 간 문맥 전환을 효율적으로 지원함.
        - 하지만 사용자 레벨 스레드는 OS가 직접 관리하지 않으므로, 문맥 전환을 setjmp/longjmp 같은 방식으로 직접 처리해야 함
        - 결과: 디버깅・유지보수가 어려워지고, 처리 과정에서 추가 오버헤드가 생길 수 있음
- 운영체제 차원에서 ‘경량 스레드’를 별도로 지원하지 않는 이유
    - 기능 중복과 복잡성 증가
        - OS는 이미 커널 스레드(Kernel-Level Thread) 스케줄러를 갖추고 있음.
        - 여기에 “경량 스레드 전용 스케줄러”까지 운영체제 단에서 직접 지원하면, 코드 구조가 복잡해지고 유지보수 비용이 커짐
        - 사용자 레벨 스레드가 필요한 경우, 언어나 라이브러리(예: Go 루틴, Green Thread)에서 구현하는 방식이 훨씬 유연하고 서로 간섭이 적음
    - 시스템 콜 계층의 복잡성
        - 사용자 레벨 스레드를 OS 차원에서 온전히 지원하려면, 블로킹 시스템 콜을 내부적으로 ‘논블로킹 I/O’처럼 다룰 수 있게 커널에서 많은 처리를 해줘야 함
        - 이미 epoll, kqueue, IOCP 같은 비동기 I/O 모델을 갖추고 있으므로, 라이브러리나 런타임 차원에서 이것들을 활용해 경량 스레드를 구현하는 편이 일반적이고 간단함
    - 성능 이득이 명확하지 않음
        - 과거에는 커널 스레드 문맥 전환 비용이 크다는 점이 사용자 레벨 스레드의 장점이었지만, 현대 OS와 하드웨어는 스레드 전환을 상당히 빠르게 처리함
        - 또한 멀티코어(SMP) 환경에선, 커널이 스레드 단위로 코어 자원을 관리하고 스케줄링하는 게 유리함
        - 결과: “경량성” 하나만을 위해 운영체제 구조를 복잡하게 만드는 것은 실익이 적음
- 실제 구현
    - Go 언어의 고루틴(Goroutine)
    - 커널이 관리하는 스레드는 M개만 만들어두고, Go 런타임이 사용자 레벨 스레드(고루틴) N개를 그 위에 매핑하는 구조(M:N)를 사용
    - 필요하다면 런타임이 ‘스레드’를 조금씩 늘리거나 줄이는 식으로 동적 관리하여 성능과 자원 사용 효율을 높임
    - 그러나 이런 방식에서도, 
        - 근본적으로 커널 레벨 스레드가 있어야 실제 CPU 시간을 나누어 쓸 수 있으며, 
        - I/O가 막힐 때는 자동으로 다른 커널 스레드로 스위칭됨
- 결론
    - 운영체제 입장에서는, 커널 스레드를 표준적으로 제공하고 비동기 I/O 메커니즘(예: epoll, IOCP 등)을 마련해두는 것만으로도 충분
    - 그 위에서 사용자 레벨(라이브러리/언어 런타임)이 자유롭게 경량 스레드를 구현하는 편이 전체적으로 더 효율적이고 유연
    - OS 차원에서 별도의 “경량 스레드”를 직접 지원할 필요성과 이점이 크지 않은 것
    - 사용자 레벨 스레드(경량 스레드)는 운영체제에서 “직접 관리”하기보다는,
        - 운영체제는 최소한의 블로킹・비동기 I/O 인프라를 잘 제공하고, 
        - 그 위에서 사용자 레벨 런타임이 자유롭게 경량 스레드를 구현하도록 맡기는 흐름이 `표준`

## 채널 channel
- 고루틴간 통신할 때 사용
- 동시에 실행되는 스레드끼리 데이터를 주고 받기 위해, 공유 메모리에 동시에 접근해야 함
- 그래서 동기화 기법을 사용해서 동시에 접근해도 문제가 발생하지 않도록 해야 함
    - __동기화(Synchronization)란__
        - 여러 개의 Goroutine(혹은 스레드)이 공유 데이터에 동시에 접근할 때, 
        - 데이터의 일관성을 유지하고 충돌(Race Condition)을 방지하는 기법
- 원리
    - 채널에 데이터를 보내는 코드가 실행되면, 채널 버퍼에 접근할 때 세마포어 처럼 버퍼 크기 만큼 count를 --해주는 로직 실행
    - 만약 0보다 작으면 block 처리 됨 (핀토스 세마포어 sema_down 구현체 생각해보자) - 대기 리스트에 스레드를 넣고, 스케줄링 리스트에서 제거함
    - 그렇지 않으면 count를 --하고 작업 수행. 채널 버퍼를 수신하고 있는 스레드의 read 함수(이름이 이게 아닐 수 있음, 추측한 거임)를 실행
    - 수신 고루틴의 read가 실행된 후에는 다시 sema_up 같은 함수가 실행되어서 송신측 스레드가 스케줄링되고 다시 데이터를 송신할 수 있는 상태가 됨

## 언버퍼드 채널(Unbuffered Channel)
- 버퍼 크기가 0인 채널
- 반드시 수신자가 있어야 함. 아직 없는 상태에서 데이터를 보내면 바로 데드락 발생
- 현재 접근 가능 count(버퍼 남은 개수)가 0이면 데이터를 보낼 때 락을 걸고, 받을 때 해제를 해줘야 하는데, 
- 받아가질 않으니, 계속 lock이 걸려있고 해제가 안된 상태에서 데이터를 보낸 쪽에서 락을 계속 기다리면서 데드락 발생
```go
func main() {
    ch := make(chan int) // 버퍼가 0인 채널

    go func() {
        ch <- 42 // 데이터를 보냄 (받을 Goroutine이 없으면 블로킹됨)
    }()

    val := <-ch // 데이터 받을 준비 완료
    fmt.Println("Received:", val)
}
```
- 반드시 수신자를 먼저 실행해서 데드락이 일어나지 않도록해야 함

