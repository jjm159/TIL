
# 클래스와 프로토콜 
- class와 protocol 모두 '부모'가 될 수 있다.
- 클래스 다중 상속 불가, 프로토콜 가능.
- 클래스는 저장 공간 가짐, 프로토콜은 못가짐.

# 왜???????

swift에서는 class의 다중 상속을 금지하고 protocol의 다중 상속은 허락한다. 그 이유는 '충돌' 때문이다. c++같은 경우에는 다중 상속을 허용하는데 이로 인해 부모 클래스에 같은 이름의 멤버변수나 멤버함수가 있는 경우 충돌 문제가 발생하게 된다. 그래서 다음과 같은 위험성과 해결방법을 고려하여야 한다.

예시
- C++는 다중상속이 된다.
- 다중 상속시 문제가 발생하기 때문에 자바에서는 다중 상속을 금지하였다.
- 문제점
    - 1. 두 개 이상의 클래스 내에 있는 멤버 변수 이름이 같으면 충돌 발생
    - 2. 할아버지 클래스가 동일한 경우, 중복 상속이 되는 경우 발생
- 해결 방법
    - 1. 이름 충돌은 멤버 변수 이름 앞에 클래스 명을 써준다.
    - 2. virtual 키워드로 할아버지 클래스에 선언하여 가상 기본 클래스를 만든다.
- [참고](http://www.munsam.info/xe/cplus/1548071)

swift는 이러한 문제를 해결하기 위해 클래스는 다중상속할 수 없도록 하였다. 하지만 상속을 하나만 할 수는 없다. 하나의 오브젝트가 하나의 분류만 가지는 것이 아니기 때문이다. 그래서 다중상속은 불가피하다. 그래서 swift는 충돌문제를 해결하기 위해 protocol이라는 것을 만들었다. protocol은 stored property를 갖지 못하는데, 이것이 충돌 문제를 막아준다. 애초에 상속받는 property가 메모리에 없기 때문에 충돌이 발생하지 않는 것이다. 

그렇다면 메서드는 어떻게 할까? 기본적으로 swift의 protocol은 함수도 구현체를 허용하지 않는다. 단지 선언만 있고, 컴파일러가 프로토콜을 상속받는 클래스에게 conform을 강요하는 방식으로 protocol을 사용하도록 하고 있다.  애초에 protocol에는 함수 객체가 존재하지 않기 때문에 충돌이 발생하지 않는다. 

하지만 protocol은 extension을 통해 메서드를 정의할 수 있다. 이 프로토콜을 상속받는 클래스는 이를 conform하지 않아도 그냥 사용할 수 있다. 이 때에는 충돌이 발생할 수 있다. 

```swift
protocol A {
    func test()
}
protocol B {
    func test()
}
extension A {
    func test() {
        print("A")
    }
}
extension B {
    func test() {
        print("B")
    }
}
class Test: A, B {
    var a: Int = 0
}

Test().test() // 
```

위 코드는 다음과 같은 컴파일 에러를 발생시킨다. 

- Type 'Test' does not conform to protocol 'A'
- Ambiguous use of 'test()'

모호성 문제, 즉 충돌 문제가 발생한 것이다. 두 프로토콜에 존재하는 같은 이름의 test() 객체가 함께 Test 클래스에 상속되어서 Test()를 호출할 때 어떤 함수를 참조할 지 모르게 되는 것이다. 

이러한 경우에는 Test 클래스에서 test function을 정의해 주면 해결된다. Test 클래스의 test() 함수가 메모리에 생성되고 Test 클래스의 객체는 이를 참조하기 때문이다. 

### (+) conform과 override의 차이
override는 부모에서 정의된 함수를 다시 정의할 때를 의미하는데, protocol은 선언만하고 정의는 하지 않는다. protocol을 상속받는 class는 이 선언을 conform하여 정의할 뿐이다.