# 전송 계층 - TCP, UDP
- 네트워크 계층의 한계를 보완하고 응용 계층과의 연결점을 제공하는 계층

---

## 1. 전송 계층 개요: `IP의 한계`와 `포트`

#### IP의 한계
- IP의 한계인 신뢰할 수 없는 통신(최선형 전달), 비연결 통신 보완 필요
- IP의 `한계를 보완`하는 전송 계층
- 전송 계층은 `연결형 통신`을 가능하게 함
    - TCP
    - 두 호스트가 정보를 주고 받기 전에 연결을 수립
    - 송수신하는 동안 연결을 유지하고 송수신이 끝나면 연결을 종료함
- 전송 계층은 `신뢰성 있는 통신`을 가능하게 함
    - 패킷이 수신지까지 올바른 순서대로 확실히 전달되는 것을 보장
    - 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능 제공
- 무조건 신뢰성 있는 통신이 좋은 건 아님 - 성능!!
    - UDP
    - 신뢰할 수 없는 통신, 비연결 통신을 가능하게 하여 TCP 보다 빠른 전송 가능

#### `포트`: 응용 계층과의 연결 다리
- 포트의 정의
    - 특정 애플리케이션 포르세스가 최종 수신 대상
    - 프로세스를 식별하는 정보를 포트라고 함
- 포트의 분류
    - 포트 번호가 프로세스의 식별자로 사용됨
    - 포트 번호는 16비트로 표현
    - 번호의 범위에 따라 세 종류
        - 잘 알려진 포트: 0~1023
            - FTP 20, 21, SSH 22, DNS 53, HTTP 80, HTTPS 433, ...
        - 등록된 포트: 1024~49151
            - 흔히 사용되는 애플리케이션 프로토콜에 할당하기 위해 사용
            - Redis 6379, http 대체 8080, OpenVPN 1194, MySQL 3306, ...
        - 동적 포트: 49152~65535
            - 동적 포트, 사설 포트, 임시 포트 라고도 함
            - 자유롭게 사용 
#### 정리
- 전송 계층은 신뢰할 수 있는 연결형 통신이 가능한 TCP 프로토콜을 제공하여 네트워크 계층의 한계를 보완
- 포트를 통해 응용 계층의 애플리케이션을 식별하여 응용 계층과의 연결 다리 역할 수행

#### 포트 기반 `NAT`
- IP 주소를 변환하는 기술, Network Address Translation
- 네트워크 내부에서 사용되는 사설 IP 주소와 네트워크 외부에서 사용되는 공인 IP 주소를 변환하는 데 사용
- `NAT 변환 테이블`
    - 변환의 대상이 되는 IP 주소 쌍 명시
    - 사설 ip와 공인 ip의 1대 1 대응은 공인 IP가 부족하기 때문에 문제가 있음
    - 그래서 다수의 사설 IP를 하나의 공인 IP로 변환하도록 할 수 있음 
- `NAPT`
    - 포트 기반의 NAT - Network Address Port Translation, APT라고도 함
    - 포트를 활용하여 하나의 공인 IP를 다수의 사설 IP가 공유할 수 있도록 함
    - 포트를 같이 기록!
    - "1.2.3.4:6200":"192.168.0.5:1025"
    - 외부에서 사용하는 공인 IP가 같아도 포트가 다르면 네트워크 내부의 호스트를 특정할 수 있음
    - 공인 IP 주소 수 부족 문제를 개선한 기술!!!

#### 포트 포워딩
- 네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고, 
- 해당 IP 주소:포트번호로써 해당 호스트에게 패킷을 전달하는 기능
- 내트워크 외부에서 내부로 접속하려는 상황
    - 처음 패킷을 보내는 호스트 입장에서는 어떤 사설 IP가 수신지인지 결정 못함
    - 하나의 공인 IP를 여러 사설 IP가 공유하고 있기 때문에!
- 특정 IP 주소와 포트 번호 쌍을 특정 호스트에게 할당
    - 외부에서 해당 접속 정보(IP주소:포트번호)로 접속

---

## 2. TCP와 UDP

#### TCP 통신 단계와 세그먼트 구조
- 세 단계
    - 연결 수립 -> 데이터 송수신 -> 연결 종료
- `MSS` - maximum segment size
    - TCP로 전송 가능한 최대 페이로드 크기
    - 헤더는 제외
- 헤더
    - 송신지 포트, 수신지 포트
    - 순서 번호
        - 송수신되는 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호
    - 확인 응답 번호
        - 상대 호스트가 보낸 세그먼트에 대한 응답.
        - 다음으로 수신하기를 기대하는 순서 번호가 명시
    - 제어 비트
    - 윈도우
        - 수신 위도우 크기, 한번에 수신하고자 하는 크기
- 제어 비트
    - 8비트
    - `ACK`: 세그먼트 승인을 나타내는 비트
    - `SYN`: 연결을 수립하기 위한 비트
    - `FIN`: 연결 종료 위한 비트
- `순서 번호`
    - 세그먼트의 순서 보장을 위한 번호
    - SYN가 1인 세그먼트의 순서 번호는 무작위 값 -> `초기 순서 번호`
    - 연결 수립 후 데이터 송신 중에 있는 순서 번호는 `초기 순서 번호 + 송신한 바이트 수`
    - 4바이트를 넘어가면, 다시 0부터 시작
- `확인 응답 번호`
    - 다음에 보내기를 바라는 순서 번호가 `확인 응답 번호`
    - 일반적으로 `수신한 순서 번호 + 1`

#### TCP 연결 수립과 종료
- 연결 수립: `3-way handshake`
    - A->B: SYN
    - B->A: SYN+ACK
    - A->B: ACK
- 연결 종료
    - A->B: FIN
    - B->A: ACK
    - B->A: FIN
    - A->B: ACK

#### TCP 상태
- 연결형 통신과 신뢰할 수 있는 통신 유지를 위해 다양한 상태를 유지
- 상태는 어떤 통신 과정에 있는지를 나타냄
- TCP는 스테이트풀 프로토콜
- 상태
    - 연결이 수립되지 않은 상태
        - CLOSED, LISTEN
    - 연결 수립 상태
        - SYN-SENT, SYN-RECEIVED, ESTABLISHED
    - 연결 종료 상태
        - FIN-WAIT-1, CLOSE-WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT
- __TIME-WAIT 왜 필요?__
    - 마지막 ACK를 못 받았을 수 있음
    - TIME-WAIT 없이 바로 종료하면, ACK를 못받았을 때 재전송을 받을 수 없음
    - 연결을 종료하고 다른 연결 전에 대기 시간이 없으면, 서로 다른 연결의 패킷들이 혼란을 야기할 수 있음

#### UDP 데이터그램 구조
- UDP는 비연결 통신, 신뢰할 수 없는 프로토콜
- 스테이트리스 프로토콜
- 데이터그램 구조
    - |송신지포트|수신지포트|길이|체크섬|
- 실시간성이 강조되는 상황에서 TCP보다 더 많이 쓰임
- 패킷이 손실되거나 순서가 바뀔 수도 있음

---

## 3. TCP의 오류, 흐름, 혼잡 제어
- TCP의 신뢰성을 보장하기 위한 기법들
- 연결 수립 -> `데이터 송수신` -> 연결료종료
- 데이터 송수신 중에 패킷이 잘못 전달 될 때 처리 방법들

## 오류 제어: `재전송 기법`
- 신뢰성 보장을 위해서 다음 기능 필요
    - 송신 호스트가 송신한 세그먼트에 문제가 발생함을 인지
    - 오류를 감지했을 때 해당 세그먼트를 재전송
- `오류 검출` : 세그먼트에 문제가 있음을 인지하는 방법
    - 1. 중복된 ACK 세그먼트를 수신했을 때 
        - 수신 측에서 세그먼트 중 일부를 누락하였을 때, 중복된 ACK를 전송하게 됨
        - 수신 측은 다음에 받아야 할 패킷의 번호를 ACK에 담아 보내는데, 
        - 해당 패킷을 못받으면, 다시 해당 ACK를 보냄
    - 2. 타임 아웃이 발생했을 때
        - 송신자는 재전송 타이머(retransmission timer) 값을 유지
        - 세그먼트를 보낼 때 재전송 타이머 시작하여 카운트 다운 시작
        - 카운트 다운이 끝나면 이를 `타임 아웃`이라 함
        - 타임 아웃이 발생했는데 ACK를 못받았다면 세그먼트가 전달되지 않았다고 봄
        - 재전송!
    - `빠른 재전송` fast retransmit
        - 재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트를 받았다면 곧바로 재전송
        - 타이머가 끝날 때까지 기다리는 시간을 줄일 수 있음
- `ARQ`: 재전송 기반 오류 제어
    - Automatic Repeat Request, 자동 재전송 요구
    - 수신 호스트의 답변(ACK)과 타임아웃을 토대로 문제를 진단,
    - 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식
    - ARQ 세 가지 방식
        - Stop-and-Wait ARQ
        - Go-Back-N ARQ
        - Selective Repeat ARQ
- `Stop-and-Wait ARQ`
    - 송신하고 확인받고 송신하고 확인받고
    - 제대로 전달되었음이 확인되기 전까지 새로운 메시지 보내지 않음
    - 장: 단순하고 높은 신뢰성 보장
    - 단: 네트워크 이용 효율이 낮아지고 성능이 저하됨
    - 단점 해결 방법
        - 각 세그먼트의 ACK 세그먼트가 오기 전에 여러 세그먼트를 보낼 수 있어야 함
        - `파이프라이닝`
            - 연속해서 메시지를 전송할 수 있는 기술
- `Go-Back-N ARQ`
    - 파이프라이닝 기반 ARQ 일종
    - 여러 세그먼트 전송 중 오류가 발생하면 해당 세그먼트부터 전부 재전송
    - 순서 번호 N번에 대한 ACK 세그먼트
        - N번만의 확인 응답이 아니라
        - N번까지의 누적 확인 응답
            - N번까지 잘 받았음! 그 이후로는 왔지만 중간에 빼먹어서 온 게 아닌걸로 침!
    - `누적 확인 응답`
        - CACK - Cumulative Acknowledgment
- `Selective Repeat ARQ`
    - 선택적으로 재전송
    - 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
    - `개별 확인 응답` Selective Acknowledgment
    - 오늘 날 대부분 이 방법 지원
    - 이 방법을 사용하지 않는 경우 Go-Back-N ARQ로 동작

## 흐름 제어: `슬라이딩 윈도우`
- 파이프라이닝 기반
    - 한 번에 무한히 많은 데이터를 보내고 받을 수 있을까?
- 파이프라이닝 기반 ARQ가 정상 동작하려면...
    - 수신 호스트가 한 번에 얼마나 받아 처리할 수 있는지 반드시 고려해야 함
    - 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있기 때문
- TCP의 흐름제어
    - 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 기능
    - 파이프라이닝 기반의 ARQ에서는 흐름 제어 필요
    - 반대로 Stop-and-Wait ARQ는 별도의 흐름제어 필요 없음
- `슬라이딩 윈도우`
    - TCP 흐름제어 기법
    - 윈도우
        - 송신 호스트가 파이프라이닝할 수 있는 최대량
        - 윈도우의 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능하다는 의미
    - ACK 세그먼트를 받으면
        - 윈도우는 오른쪽으로 한 칸 이동
- 윈도우 계산
    - 수신 호스트는 TCP 헤더의 윈도우 필드로 자신이 받을 데이터 양을 수신 호스트에게 알려줌
    - 송신 윈도우는 헤더로 받은 이 수신 윈도우 값을 토대로 연산함
    - 수신자, 송신자 모두 각각 윈도우를 가지고 데이터를 주고 받을 때 마다 윈도우를 계산하여 이동함


## 혼잡 제어
- 혼잡(congestion)?
    - 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황
    - TCP 개발 초기에는 이러한 혼잡 현상에 따른 전송률 저하가 큰 골칫거리
- `혼잡 제어`
    - 송신 호스트는 네트워크 혼잡도를 파악하여 유동적으로 전송량을 조절하여 전송
        - 흐름 제어의 주체가 수신 호스트라면, 혼잡 제어의 주체는 송신 호스트
    - `혼잡 윈도우`
        - 혼잡 없이 전송할 수 있을 법한 데이터 양
        - 이게 크면 한 번에 전송할 수 있는 세그먼트의 수가 많음
        - 어디에?
            - tcp 관리하는 변수로 관리됨(BSD 소켓 같은 운영체제 코드에서!)
            - 수신 윈도우는 수신 호스트가 헤더를 통해 알려주지만, 
            - 혼잡 윈도우는 송신 호스트가 알아서 직접 계산해서 알아내야 함
    - 혼잡 윈도우 크기
        - 혼잡 제어 알고리즘으로 결정
- AIMD - Addictive Increase/Multiplicative Decrease
    - 합으로 증가, 곱으로 감소
    - RTT 마다 혼잡 윈도우를 1씩 증가, 혼잡 감지시 윈도우 크기를 절반으로 떨어뜨림
    - `RTT`
        - Round Trip Time
        - 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간
- 느린 시작 알고리즘 - slow start
- 혼잡 회피 알고리즘 - congestion avoidance
- 빠른 회복 알고리즘 - fast revovery

---

## 참고 
- 혼자 공부하는 네트워크