# 프로세스 스케줄링은 언제 일어나는가?

## 개요
- 이전 부터 어렴풋이 궁금했던 것인데, 핀토스를 구현하다 보니 더 질문이 구체화되었다.
- 핀토스에서는 스케줄링의 단위를 thread로 잡고 진행한다.
- 프로세스의 스케줄링이 일어나는 코드를 아직 보지 못했다. 
- 프로세스의 컨텍스트 스위칭은 언제 어디서 이루어지는 걸까?
- gpt와의 대화를 기록해본다.

---

## gpt와의 대화

### 프로세스안에 스레드를 여러개 만들자너? os가 스케줄링할 때, 스레드를 기준으로 해? 그러면 프로세스의 context switching은 언제 해?

OS는 스케줄링을 할 때, 프로세스 내의 개별 스레드를 기준으로 스케줄링을 합니다. 즉, 스레드 단위로 CPU 자원을 할당합니다. 이는 각각의 스레드가 독립적으로 CPU를 얻어 실행될 수 있음을 의미하며, 여러 스레드가 동시에 실행 중일 경우 스레드 간의 context switching이 이루어집니다.

프로세스와 스레드의 컨텍스트 스위칭

	1.	스레드 컨텍스트 스위칭: OS가 한 프로세스 내의 여러 스레드를 스케줄링할 때, 스레드마다 별도의 스택과 레지스터 상태를 가지고 있기 때문에 해당 정보를 교체하여 스위칭을 수행합니다.
	2.	프로세스 컨텍스트 스위칭: OS가 다른 프로세스로 전환해야 할 때 프로세스 컨텍스트 스위칭이 발생합니다. 이 경우 프로세스 전체의 메모리 맵, 페이지 테이블, 파일 디스크립터 테이블 등 프로세스 관련 리소스를 교체하게 됩니다. 주로 다음 상황에서 프로세스 컨텍스트 스위칭이 발생합니다:
	•	프로세스가 블록되거나 종료될 때
	•	프로세스가 긴 대기 시간을 가진 작업을 수행할 때
	•	다른 프로세스에 더 높은 우선순위가 부여될 때

즉, 스레드 기준으로 스케줄링이 이루어지지만, 프로세스 간의 전환이 필요하면 프로세스 전체의 리소스도 교체하게 되어, 프로세스의 컨텍스트 스위칭이 일어나는 것입니다.

### os의 스케줄러는 thread를 스케줄링할 때, 이전과 다른 프로세스의 thread이면 프로세스 context switching을 해주는거야?

맞아. OS의 스케줄러가 스레드를 스케줄링할 때, 이전과 다른 프로세스의 스레드로 전환하려면 프로세스의 컨텍스트 스위칭이 필요해.

프로세스 컨텍스트 스위칭 과정

	1.	현재 프로세스의 상태 저장: 현재 실행 중인 프로세스의 메모리 맵, 페이지 테이블, 파일 디스크립터 등 관련 정보가 저장됨.
	2.	새로운 프로세스의 정보 로드: 전환될 프로세스의 메모리 맵과 페이지 테이블이 로드되어 해당 프로세스가 필요한 리소스를 사용할 수 있게 준비함.
	3.	새 스레드 실행: 전환된 프로세스의 지정된 스레드가 CPU에 할당되어 실행을 시작함.

이 과정에서 같은 프로세스 내에서 스레드 전환이 일어날 때는 메모리 맵이나 페이지 테이블 등의 변경이 필요 없으므로 스레드 컨텍스트 스위칭만 수행하면 돼. 반면, 다른 프로세스의 스레드로 전환될 때는 프로세스 컨텍스트 스위칭이 추가로 일어나야 해.

### 그걸 os가 일일이 체크해서 한다는 말이지?

맞아, OS가 일일이 체크해서 처리해. OS의 스케줄러는 스레드마다 어느 프로세스에 속해 있는지 정보를 가지고 있고, 다른 프로세스의 스레드로 전환할 때는 프로세스 컨텍스트 스위칭이 필요하다는 걸 인식해 그에 맞는 작업을 수행해.

	•	스레드 전환 시: OS는 스레드가 같은 프로세스 내에 있으면 스레드 컨텍스트 스위칭만 수행하고,
	•	다른 프로세스의 스레드로 전환 시: OS는 프로세스의 정보도 같이 교체하는 프로세스 컨텍스트 스위칭을 진행해.

이 과정을 통해 OS는 성능을 최적화하면서도 서로 다른 프로세스의 메모리와 자원이 안전하게 분리된 상태로 실행되도록 보장해.

### 핀토스에서는 스레드의 컨텍스트 스위칭만 해? 아니면 프로세스 컨텍스트 스위칭도 해?

핀토스(Pintos)는 주로 스레드 기반의 커널을 구현하는데 초점이 맞춰져 있어서, 기본적으로 스레드 컨텍스트 스위칭만 수행해. 핀토스에서는 스레드가 프로세스의 역할을 하며, 프로세스 컨텍스트 스위칭에 해당하는 기능이 간소화되어 있어.

	•	스레드 컨텍스트 스위칭: 핀토스의 기본 구현에서는 스레드를 스케줄링 단위로 사용하고, 스레드 간의 컨텍스트 스위칭이 주된 작업이야. 이 과정에서 CPU 레지스터와 스택 포인터, 프로그램 카운터 등이 스위칭되는 수준으로 관리돼.
	•	프로세스 컨텍스트 스위칭: 핀토스에서 실제 사용자 프로그램을 실행하는 구조를 확장하면서, 사용자 스레드와 커널 스레드 간의 컨텍스트 스위칭 개념이 들어가게 돼. 이때 사용자 프로그램의 메모리 공간이나 레지스터 등의 교체가 포함된다고 볼 수 있지만, 일반적인 OS의 프로세스 컨텍스트 스위칭처럼 전체 주소 공간을 교체하는 방식은 아니야.

즉, 핀토스의 기본 커널은 사용자 프로세스를 완전하게 지원하지 않기 때문에, OS에서 일반적으로 말하는 프로세스 컨텍스트 스위칭보다는 스레드 스위칭을 기반으로 작동한다고 할 수 있어.

### 일반 리눅스나 윈도우같은 운영체제는 스레드를 기존 스케줄링 단위로 하지만, 스레드의 프로세스가 이전과 바뀌는 경우에 프로세스 컨텍스트 스위칭을 같이 진행한다는 말이지? 이 조건문이 커널 코드에 있다는 말이지? 

맞아! 일반적인 리눅스나 윈도우 같은 운영체제에서는 스레드를 기본 스케줄링 단위로 사용해. 그리고 스레드를 스위칭할 때, 새로운 스레드가 이전 스레드와 다른 프로세스에 속해 있다면 프로세스 컨텍스트 스위칭도 같이 진행해.

이러한 조건문은 커널 코드 안에 존재하며, 스케줄러는 스레드가 다른 프로세스에 속해 있는지 여부를 판단해 필요한 경우에만 프로세스 컨텍스트 스위칭을 수행해. 이때 프로세스 컨텍스트 스위칭에는 주소 공간, 페이지 테이블, 그리고 프로세스에 관련된 특정 정보들이 함께 교체돼.

구체적으로:

	1.	스레드 스케줄링: 스케줄러가 실행할 다음 스레드를 선택하고, 스레드 컨텍스트 스위칭을 수행해.
	2.	조건 체크: 새 스레드의 프로세스가 이전 스레드와 다르다면, 프로세스 관련 데이터(예: 페이지 테이블, 메모리 매핑)를 전환해야 함을 인지해.
	3.	프로세스 컨텍스트 스위칭: 필요한 경우 새로운 프로세스의 주소 공간과 메모리 맵핑, 페이지 테이블 정보 등 프로세스 관련 정보를 로드하는 과정이 이어져.

이 조건이 스케줄러의 커널 코드 안에 존재하기 때문에, 프로세스가 달라질 때만 프로세스 컨텍스트 스위칭이 수행되고, 같은 프로세스 내의 스레드끼리는 스레드 컨텍스트 스위칭만 수행해 효율적으로 작동할 수 있게 돼.

### 오픈소스 리눅스 커널 코드 중에 이 조건을 체크하는 부분을 알려줄 수 있어?

리눅스 커널에서 스레드가 다른 프로세스에 속해 있는지 확인하고 필요할 때만 프로세스 컨텍스트 스위칭을 수행하는 부분은 스케줄러와 관련된 코드 중에 있습니다. 리눅스 커널의 context_switch 함수가 이를 담당하는데, 이 함수는 kernel/sched/core.c 파일에 정의되어 있습니다.

주요 코드 위치 및 내용

	1.	context_switch() 함수:
	•	파일 위치: kernel/sched/core.c
	•	이 함수는 커널 스케줄러가 현재 실행 중인 태스크와 새로 실행될 태스크 간의 스위칭을 수행하는 곳입니다.
	•	코드 일부를 살펴보면, 이 함수는 prev와 next라는 두 태스크(스레드/프로세스)를 인자로 받아 필요 시 프로세스 관련 정보도 스위칭합니다.

```c
static inline void context_switch(struct rq *rq, struct task_struct *prev,
                                  struct task_struct *next)
{
    // 여러 초기화 및 준비 작업 수행
    struct mm_struct *oldmm, *newmm;

    oldmm = prev->active_mm;
    newmm = next->mm;

    /* Check if the process has changed */
    if (unlikely(!newmm)) {
        next->active_mm = oldmm;
        enter_lazy_tlb(oldmm, next);
    } else {
        switch_mm(oldmm, newmm, next);
    }

    rq->curr = next;
    /* 스택 및 레지스터 스위칭 수행 */
    switch_to(prev, next, prev);
}
```

	2.	switch_mm() 함수:
	•	프로세스 주소 공간 전환을 수행하는 함수입니다. 여기서 oldmm과 newmm을 비교하여 프로세스가 변경될 경우 페이지 테이블 정보 등을 스위칭합니다.
	•	만약 prev와 next가 같은 프로세스라면 이 전환 작업을 건너뛰고, 스레드 간 컨텍스트 스위칭만 수행하게 됩니다.
	3.	핵심 로직:
	•	context_switch()에서 oldmm과 newmm을 비교해 프로세스가 변경되었는지 확인하고, 프로세스가 변경된 경우에만 switch_mm()을 호출해 프로세스의 메모리 맵과 페이지 테이블을 전환합니다.
	•	이후 switch_to()가 호출되어 스레드 레벨의 스택과 레지스터를 교체합니다.

요약

이러한 구조 덕분에 커널은 다른 프로세스 스레드로의 전환 시에만 프로세스 컨텍스트를 스위칭하고, 그렇지 않으면 스레드 컨텍스트 스위칭만 수행하여 효율성을 유지할 수 있습니다.

리눅스 커널 코드는 계속 업데이트되므로 커널 버전에 따라 코드가 일부 다를 수 있습니다. kernel/sched/core.c의 context_switch()와 switch_mm()가 핵심 로직이란 점에서 참고가 될 것입니다.


### task 타입은 스레드인건가?

리눅스 커널에서 task_struct 구조체는 프로세스와 스레드를 포함한 **모든 실행 단위(Task)**를 표현하는 데 사용됩니다. 리눅스에서는 프로세스와 스레드를 구분하지 않고 동일한 task_struct 구조체로 관리하기 때문에, task_struct 타입의 인스턴스는 프로세스일 수도 있고 스레드일 수도 있습니다.

리눅스에서는 프로세스와 스레드를 동일하게 **태스크(Task)**로 간주합니다. 둘 다 task_struct를 통해 표현되며, 다음과 같은 방식으로 구분합니다:

	1.	프로세스: 독립적인 메모리 공간을 가지며, 새로운 task_struct로 생성됩니다.
	2.	스레드: 동일한 프로세스 내에서 메모리 공간을 공유하지만, 개별 task_struct 인스턴스로 관리됩니다. 이 스레드는 부모 프로세스의 메모리 영역을 공유하도록 task_struct 속성이 설정됩니다.

따라서 스레드와 프로세스 모두 task_struct로 표현되지만, 공유되는 메모리 맵이나 thread_group 등의 필드를 통해 스레드 간 공유 여부를 결정하게 됩니다.

### 그러면 context switching 할 때, 프로세스랑 스레드가 방법이 다른데, 같은 task struct로 관리하면, 어떻게 구분해서 처리해?

리눅스 커널에서는 **task_struct**를 통해 프로세스와 스레드를 동일한 방식으로 관리하지만, 컨텍스트 스위칭에서 프로세스와 스레드의 차이를 구분하는 방법은 메모리 공간을 공유하는지 여부와 태스크의 그룹 정보를 참조하는 것입니다. 즉, 스레드와 프로세스가 공유하는 자원들을 기준으로 필요한 단계만 수행하게 됩니다.

컨텍스트 스위칭에서 스레드와 프로세스를 구분하여 처리하는 과정은 대략 다음과 같은 방식으로 이루어집니다.

	1.	현재 태스크가 스레드인지 프로세스인지 확인:
	•	task_struct 내의 mm 필드를 확인합니다.
	•	**mm 필드가 NULL**이면, 해당 태스크는 커널 스레드입니다.
	•	mm 필드가 프로세스 메모리 공간을 가리키면 해당 태스크는 일반적인 유저 프로세스 또는 스레드입니다.
	2.	필요에 따라 mm_struct(메모리 맵) 스위칭:
	•	두 태스크가 서로 다른 mm 구조체를 가진 경우, 프로세스 컨텍스트 스위칭이 필요하며, CPU의 CR3 레지스터를 업데이트하여 새로운 주소 공간을 로드합니다.
	•	만약 두 태스크가 같은 mm 구조체를 공유한다면 스레드 간 컨텍스트 스위칭에 해당하여 CR3를 업데이트하지 않고 레지스터 등만 스위칭합니다.
	3.	스케줄링 코드 내 조건문:
	•	스케줄러에서 컨텍스트 스위칭 시, 이전 태스크와 다음 태스크 간의 mm 필드를 비교하여 같은 메모리 맵을 공유하는지 확인합니다.
	•	메모리 맵이 다르면 프로세스 전환을, 같으면 스레드 전환만 수행합니다.

이러한 구분은 switch_to() 함수에서 수행됩니다. 이 함수는 task_struct를 기반으로 레지스터와 스택 포인터 등 문맥 저장과 복구 작업을 수행하며, 메모리 공간 전환이 필요한 경우에만 추가로 메모리 맵을 전환하여 프로세스와 스레드를 구분한 맞춤형 컨텍스트 스위칭을 합니다.

---

## 정리
- 리눅스는 프로세스와 스레드를 task로 관리한다.
- task의 mm을 확인해서 다른 주소공간인 경우 프로세스의 컨텍스트 스위칭을 함께 해준다.