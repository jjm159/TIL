# 트랜잭션 격리 수준 (transaction isolation level)
- RDBMS는 isolation을 여러 수준에서 제공함
- isolation이 제대로 동작하지 않을 때 현상들 설명
- isolation level에 대해 설명
- snapshot isolation도 자세히!
- 개발자는 isolation level을 어떻게 접근해야 하는지!

## isolation(격리)이란?
- 트랜잭션이 동시에 실행될 때,
- 하나의 트랜잭션 내에 실행되는 일련의 연산들은
- 마치 하나의 트랜잭션만 실행중인 것처럼,
- 동시에 실행되는 다른 트랜잭션의 영향을 받지 않아야 한다는 원칙
- __아래 이상 현상 세 가지는 isolation이 제대로 동작하지 않아 발생하는 현상들__ 

## dirty read
- commit 되지 않은 변화를 읽음
- 예시:
    - x = 10, y = 20
    - 트랜잭션
        - t1: x에 y를 더함, t2: y를 70으로 바꿈
- 진행 (위에서 아래로 순서대로)
    - t1: read(x) => 10
    - t2: write(y = 70)
        - x = 10, y = 70
    - t1: read(y) => 70
        - t2에 의해 바뀐 y를 읽게 됨
        - `dirty read` 발생
        - 아직 t2가 commit되지 않았는데 읽음
        - t2가 rollback되면 t1은 잘못된 값을 읽어와서 연산을 진행한 것
    - t1: write(x = x + y) => write(x = 10 + 70)
        - x = 80, y = 70
    - t1: commit
    - t2: abort: rollback(y = 20)
        - x = 80, y = 20
- 문제
    - t2가 commit되지 않은 상태에서 y를 읽어 들이고 x를 수정한 t1
    - t2가 rollback을 해버리면서 t1이 수정한 x는 이상한 값이 되어 버림
    - isolation 관점에서 동시에 실행되어도 지금 이 트랜잭션만 실행되는 것처럼 실행되어야 하는데,
    - 동시에 실행된 t2의 결과 때문에 t1이 영향을 받음. 심지어 rollback되어 결과도 옳지 않게 됨.

## Non-repeatable read
- 같은 데이터의 값이 달라짐
    - 하나의 트랜잭션 안에서 값을 두 번 이상 읽었을 때 값이 다르게 읽힘
- `Fuzzy read` 라고도 함
- 예시:
    - x = 10
    - t1: x를 두 번 읽음, t2: x에 40을 더함
- 진행
    - t1: read(x) => 10
    - t2: read(x) => 10
    - t2: write(x = 50)
    - t2: commit
    - t1: read(x) => 50
        - 여기서 문제 발생!!! Fuzzy read 발생
        - t1 안에서 x를 수정한 적이 없으니 여러 번 읽어도 x가 똑같아야 하는데,
        - t2로 인해 t1의 x가 다른 값으로 읽힘
    - t1: commit
- 문제
    - isolation 관점에서 일어나면 안되는 현상
    - __여러 트랜잭션이 동시에 실행되더라도 각 트랜잭션이 혼자 실행되는 것처럼 실행되어야 함__
    - 다른 트랜잭션과 동시에 실행되더라도 t1만 실행되는 것처럼 보여야 하기 때문에
    - t1이 두 번 x를 읽었을 때 두 값이 같게 나와야 함

## phantom read
- 없던 데이터가 생김
- 예시:
    - tuple1(..., v=10), tuple2(..., v=50)
    - t1: v가 10인 데이터를 두 번 읽음, t2: tuple2의 v를 10으로 바꿈
- 진행
    - t1: read(v=10) => tuple1
    - t2: write(tuple2.v=10)
        - tuple1(..., v=10), tuple2(..., v=10)   
    - t2: commit
    - t1: read(v=10) => tuple1, tuple2
        - t1 트랜잭션 안에서 아까 읽었던 것과 다르게 없던 데이터 tuple2가 생김
    - t1: commit
- 문제
    - 하나의 트랜잭션 안에서 동일한 조건으로 두 번 읽었는데 결과가 각각 다름
    - isolation 관점에서 이상한 현상
    - t1 안에서 tuple2를 추가한 적이 없으니, read(v=10)의 결과가 앞에서의 결과와 같아야 함
    - t2의 write에 의해 t1 안에서의 똑같은 조건을 가진 read의 결과가 바뀜

## isolation level (표준 SQL 기준)
- 트랜잭션의 동시 실행 문제
    - 이상한 현상, 데이터 불일치를 발생시키는 현상들 발생
        - Dirty read - commit 되지 않은 변화를 읽음
        - Non-repeatable read - 트랜잭션 내에서 같은 데이터의 값이 바뀜
        - Phantom read - 트랜잭션 내에서 없던 데이터 생김
    - 이 현상들이 모두 발생하지 않게 만들 수 있음
    - 그러면 제약사항이 많아져서 동시 처리 가능한 트랜잭션의 수가 줄어들어
    - 결국 DB의 전체 처리량(throughput)이 하락하게 된다.
- 해결
    - 일부 이상한 현상은 허용하는 몇 가지 level을 만들어서 
    - 사용자가 필요에 따라 적절하게 선택할 수 있게 하자
    - 이게 바로 `Isolation level`
- Isolation level
    - `Read uncommitted`
        - 세 현상 모두 허용
    - `Read committed`
        - Dirty read 허용 X, 나머지 허용
    - `Repeatable read`
        - Dirty read, Non-repeatable read 허용, Phantom read 불허
    - `Serializable`
        - 모두 불허
        - 위 세가지 현상 뿐 아니라 모든 이상 현상이 일어나지 않음
- __세 가지 이상 현상을 정의하고 어떤 현상을 허용하는지에 따라 각각의 isolaction level이 구분됨__
- 애플리케이션 설계자는 isolation level을 통해
    - 전체 처리량(throughput)과 데이터 일관성 사이에서
    - 어느 정도 거래(trade)를 할 수 있다.
    - __성능 vs 일관성__ trade-off 고민하고 선택!!

## 표준 isolation level 비판 논문
- 여기까지 정리된 내용들은 1992년 11월에 발표된 SQL 표준에서 정의된 내용
- ANSI/ISO standard SQL 92에서 정의한 isolation level을 비판하는 논문 등장 1995년에!
- `standard SQL 92 isolation level`에 대한 3가지 비판
    - 1. 세 가지 이상 현상의 정의가 모호하다.
        - 예를 들어 설명했을 뿐, 일반화하여 설명하는 것이 부족
    - 2. 이상 현상은 세 가지 외에도 더 있다.
    - 3. 상업적인 DBMS에서 사용하는 방법을 반영해서 isolation level을 구분하지 않았다.

## dirty write
- commit 되지 않은 데이터를 write 함
- 예시
    - x = 0
    - t1: x를 10으로 바꾼다, t2: x를 100으로 바꾼다.
- 진행
    - t1: write(x = 10)
        - x = 0 -> 10
    - t2: write(x = 100)
        - x = 10 -> 100
        - `dirty write` 발생
        - 아직 t1이 commit되지 않았는데, 덮어 쓰기 발생
        - 다른 transaction이 아직 commit 안했는데, 해당 transaction이 조회한 값에 write 발생
    - t1: abort
        - t1이 x를 바꾸기 이전의 상태인 0으로 바꿈
- 문제
    - t1이 abort 되면 어떤 값으로 돌려야 하는가?
    - t1의 원래 값인 0으로 바꾸면?
        - t2가 이미 commit을 했다면,
        - commit을 했음에도 t2의 write(x=100)가 무효가 되어 버림
    - t2도 abort가 되면?
        - t2의 x 초기값인 10은 t1의 write의 결과 인데, 이건 abort된 값이라 옳지 않음
- 모든 isolation level에서 dirty write를 허용하면 안 된다.
    - rollback 시 정상적인 recovery는 매우 중요하기 때문!

## lost update
- 
- 예시 
    - x = 50
    - t1: x에 50을 더함, t2: x에 150을 더함
- 흐름
    - 
- 문제

## dirty read 확장판

## read skew

## write skew

## phantom read 확장판

## snapshot isolation

## 실무에서 isolation level

## 왜 여러 현상을 설명했는가?

## 마무리

