# NoSQL

## RDB 단점
- 1. `경직된 스키마`
    - column이 추가되면 **반드시 스키마를 변경**해야 함
    - 5천만개의 데이터가 있는 상태에서 column을 추가하면?
        - 대규모 write 작업 실행
        - 디비 서버 부하 발생
        - 백엔드 서버에도 영향 -> 전체 서비스 품질 저하
        - 상당히 부담스럽고 위험한 작업
    - 유연한 확장성의 부족!!!
- 2. `과도한 조인과 성능 하락`
    - 데이터 중복을 허용하지 않음
    - __중복 제거를 위해 정규화 진행__
    - 정규화로 인해 테이블이 쪼개서 저장됨
    - 데이터의 중복 저장을 줄일 수 있음
    - 하지만, 원래 데이터를 전부 읽고 싶을 때 JOIN이 필요
    - 디비 서버에서 CPU를 많이 사용, 응답 시간이 길어짐
    - __복잡한 join은 read 성능의 하락__
- 3. `scale-out 편하지 않음`
    - RDB는 기본적으로 한 대의 컴퓨터에 저장
    - 트래픽이 몰릴 때
    - read/write 연산 증가로 인해 부하 발생
    - 해결 방법
        - `scale up`을 통해 database 성능 향상
            - cpu, memory 성능 향상
        - `scale-out`을 통해 부하 분산
            - `replication` 사용
                - 두 대의 컴퓨터에 복사해서 read-only로 사용
                - 하지만 master 서버에 대한 write 부하는 여전함
                - 하지만 write가 증가하면, write 서버에 부하가 발생하는 것은 어쩔 수 없음
            - `multi-master`, `sharding`과 같은 방법으로 상황을 더 낫게 만들 수 있음
            - 하지만, RDB는 일반적으로 scale-out에 유연하지는 않음
                - replication이나 multi-master, sharding 모두,
                - 기존 디비 서버에 있는 데이터를 복사해서 옮겨야 하는데
                - 이게 부하가 크고 유연한 방법은 아님
                - sharding은 애플리케이션 로직이 복잡해지고 관리 부담을 증가시킴
    - 일반적으로 RDB는 기본이 단일 노드에서 동작하도록 설계되어 있기 때문에 NoSQL보다 scale-out에 불리함
    - 분산 저장시 join 했을 때 성능 저하되는 것도 RDB의 scale-out에 대한 제약이라고 볼 수 있음
- 4. `ACID가 성능에 영향`
    - RDB에서 트랜잭션은 ACID를 보장하려고 최대한 노력
    - 이건 장점이기도 하면서 단점을 가짐
    - ACID를 보장하려다 보니 DB 서버의 성능에 어느 정도 영향을 미침
    - 일관성 유지를 위한 동기적 디스크 쓰기로 인한 성능 저하 발생

## NoSQL 등장 배경
- 1990 후반, 2000년대 초반 인터넷 널리 보급
- SNS 등장, 폭발적 성장
- RDBMS만 가지고는 커버하기 어려운 트래픽이 발생하기 시작함
- 새로운 니즈
    - high-throughput (처리량) 요구됨
    - low-latency 요구됨
    - 비정형 데이터의 증가
        - 미리 스키마 만들고 대응하기에는 한계에 부딪힘
- 새로운 데이터베이스가 필요하지 않을까?

## NoSQL 의미
- NoSQL 등장
- sql 아니다 라는 의미는 아니고, 
- `not only sql`
- sql도 어느정도 커버하지만, 관계형 디비가 해결하지 못하는 문제를 해결하는 데이터베이스
- relational database의 단점을 보완하는 데이터베이스

## NoSQL 일반적인 특징
- 1. `유연한 스키마` (mongoDB)
    - `flexible schema`
    - 스키마가 유연함
    - 컬렉션(테이블에 해당하는) 생성
        - db.createCollection("student") 
        - 이렇게 이름만 지정하면 끝
    - 컬럼 생성
        - db.student.insertOne({ name: "jjm" })
        - 이렇게 하면 알아서 column(필드)이 생김
    - JSON 형태로 데이터를 넣어줌
    - 정의된 스키마가 따로 없어서 넣고 싶은대로 데이터를 넣을 수 있음
    - 읽기
        - db.student.find({ name: "jjm"})
        - 하면 json 형태로 반환
    - 각 row를 document라고 함
    - 전체 데이터 조회
        - db.student.find({})
    - `스키마가 없기 때문에`
        - __각 document가 서로 다른 형태로 데이터를 저장할 수 있음__
    - 단점
        - application 레벨에서 스키마 관리가 필요
        - 개발자가 collection 별로 어떤 데이터들이 들어가 있는지 관리해줘야 함
- 2. `중복 허용` (mongoDB)
    - 중복을 허용하는 컨셉. 그래서 join을 회피함
    - db.getCollection("order").find({})
    - order 1에도 p1 정보들이, order 2에도 p1 정보들이 중복되어 저장될 수 있음
    - RDB에서는 product table을 따로 만들어 외래키로 저장하여 중복을 제거했을 것
    - 장점
        - 조인이 필요 없음
        - 한번에 모든 데이터를 확인 가능함
    - 단점
        - application 레벨에서 중복된 데이터들을 모두 최신 데이터를 유지하도록 관리해야함
- 3. `scale-out 더 편함`
    - scale-out에 최적화되어 있음
    - db 서버 추가가 쉬움
    - 서버 여러 대로 하나의 `클러스터`를 구성하여 사용함
    - 클러스터 안에 있는 각 서버 노드들은 데이터들을 나눠서 저장하게 됨
    - RDB였다면 데이터를 나눠 저장했을 때, join 했을 때 네트워크 트래픽 발생 등 어려움이 발생됨
    - __`중복 허용` 해서 `join을 최소화하는 컨셉`은 `분산환경`에서 `시너지`를 내게 된다!!!!__
    - 그래서 scale-out이 편한 것!!!
- 4. `더 높은 처리량 (throughput)`
    - ACID의 일부를 포기하고 high-throughput, low-latency 추구
    - 금융, 결제, 예약 시스템처럼 consistency가 중요한 환경에서는 사용하기가 조심스러움
    - 하지만, nosql도 종류가 다양하여, ACID를 보장하는 nosql 시스템도 존재함!

## 참고 
- [NoSQL 설명](https://www.youtube.com/watch?v=sqVByJ5tbNA&t=754s)